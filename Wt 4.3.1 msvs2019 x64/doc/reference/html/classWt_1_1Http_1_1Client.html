<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wt: Wt::Http::Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wt
   &#160;<span id="projectnumber">4.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWt.html">Wt</a></li><li class="navelem"><a class="el" href="namespaceWt_1_1Http.html">Http</a></li><li class="navelem"><a class="el" href="classWt_1_1Http_1_1Client.html">Client</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classWt_1_1Http_1_1Client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wt::Http::Client Class Reference<div class="ingroups"><a class="el" href="group__http.html">HTTP protocol (Wt::Http)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An HTTP client.  
 <a href="classWt_1_1Http_1_1Client.html#details">More...</a></p>

<p><code>#include &lt;Wt/Http/Client.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Wt::Http::Client:</div>
<div class="dyncontent">
<div class="center"><img src="classWt_1_1Http_1_1Client__inherit__graph.png" border="0" usemap="#Wt_1_1Http_1_1Client_inherit__map" alt="Inheritance graph"/></div>
<map name="Wt_1_1Http_1_1Client_inherit__map" id="Wt_1_1Http_1_1Client_inherit__map">
<area shape="rect"  title="An HTTP client." alt="" coords="21,155,133,181"/>
<area shape="rect"  href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system." alt="" coords="27,80,126,107"/>
<area shape="rect"  href="classWt_1_1Core_1_1observable.html" title="A base class for objects whose life&#45;time can be tracked." alt="" coords="5,5,148,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWt_1_1Http_1_1Client_1_1URL.html">URL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class representing an URL.  <a href="structWt_1_1Http_1_1Client_1_1URL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab850f51173c33a12ec3d4b3371e7d1b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ab850f51173c33a12ec3d4b3371e7d1b0">Client</a> ()</td></tr>
<tr class="memdesc:ab850f51173c33a12ec3d4b3371e7d1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ab850f51173c33a12ec3d4b3371e7d1b0">More...</a><br /></td></tr>
<tr class="separator:ab850f51173c33a12ec3d4b3371e7d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966378bd63f2babf2f8d2beb2783e45e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a966378bd63f2babf2f8d2beb2783e45e">Client</a> (Wt::AsioWrapper::asio::io_service &amp;ioService)</td></tr>
<tr class="memdesc:a966378bd63f2babf2f8d2beb2783e45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a966378bd63f2babf2f8d2beb2783e45e">More...</a><br /></td></tr>
<tr class="separator:a966378bd63f2babf2f8d2beb2783e45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee67605e85d941cd9726da986b26532"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#abee67605e85d941cd9726da986b26532">~Client</a> ()</td></tr>
<tr class="memdesc:abee67605e85d941cd9726da986b26532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#abee67605e85d941cd9726da986b26532">More...</a><br /></td></tr>
<tr class="separator:abee67605e85d941cd9726da986b26532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8f9647e25c264cd9296a61aba16753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a3d8f9647e25c264cd9296a61aba16753">setTimeout</a> (std::chrono::steady_clock::duration <a class="el" href="classWt_1_1Http_1_1Client.html#ab98a080e1ae3a5d0e09ab0fca76a43ea">timeout</a>)</td></tr>
<tr class="memdesc:a3d8f9647e25c264cd9296a61aba16753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an I/O timeout.  <a href="#a3d8f9647e25c264cd9296a61aba16753">More...</a><br /></td></tr>
<tr class="separator:a3d8f9647e25c264cd9296a61aba16753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98a080e1ae3a5d0e09ab0fca76a43ea"><td class="memItemLeft" align="right" valign="top">std::chrono::steady_clock::duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ab98a080e1ae3a5d0e09ab0fca76a43ea">timeout</a> () const</td></tr>
<tr class="memdesc:ab98a080e1ae3a5d0e09ab0fca76a43ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the I/O timeout.  <a href="#ab98a080e1ae3a5d0e09ab0fca76a43ea">More...</a><br /></td></tr>
<tr class="separator:ab98a080e1ae3a5d0e09ab0fca76a43ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b25de10c5da7c7c5abf0892593a04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a45b25de10c5da7c7c5abf0892593a04d">setMaximumResponseSize</a> (std::size_t bytes)</td></tr>
<tr class="memdesc:a45b25de10c5da7c7c5abf0892593a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a maximum response size.  <a href="#a45b25de10c5da7c7c5abf0892593a04d">More...</a><br /></td></tr>
<tr class="separator:a45b25de10c5da7c7c5abf0892593a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d6c65425f43fb373e4b66860033d31"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ab8d6c65425f43fb373e4b66860033d31">maximumResponseSize</a> () const</td></tr>
<tr class="memdesc:ab8d6c65425f43fb373e4b66860033d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum response size.  <a href="#ab8d6c65425f43fb373e4b66860033d31">More...</a><br /></td></tr>
<tr class="separator:ab8d6c65425f43fb373e4b66860033d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54355849e1235697747eb0361eb643dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a54355849e1235697747eb0361eb643dd">setSslCertificateVerificationEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a54355849e1235697747eb0361eb643dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables SSL certificate verification.  <a href="#a54355849e1235697747eb0361eb643dd">More...</a><br /></td></tr>
<tr class="separator:a54355849e1235697747eb0361eb643dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683fec0c7c53aa39085c3455a9ba519"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ae683fec0c7c53aa39085c3455a9ba519">isSslCertificateVerificationEnabled</a> () const</td></tr>
<tr class="memdesc:ae683fec0c7c53aa39085c3455a9ba519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether SSL certificate verification is enabled.  <a href="#ae683fec0c7c53aa39085c3455a9ba519">More...</a><br /></td></tr>
<tr class="separator:ae683fec0c7c53aa39085c3455a9ba519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b8b35ab2813a22c3c2e2ae7d1f9a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ac6b8b35ab2813a22c3c2e2ae7d1f9a35">setSslVerifyFile</a> (const std::string &amp;verifyFile)</td></tr>
<tr class="memdesc:ac6b8b35ab2813a22c3c2e2ae7d1f9a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a SSL certificate used for server identity verification.  <a href="#ac6b8b35ab2813a22c3c2e2ae7d1f9a35">More...</a><br /></td></tr>
<tr class="separator:ac6b8b35ab2813a22c3c2e2ae7d1f9a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9fbf7fc9f671519b0652f3bbe38521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a7c9fbf7fc9f671519b0652f3bbe38521">setSslVerifyPath</a> (const std::string &amp;verifyPath)</td></tr>
<tr class="memdesc:a7c9fbf7fc9f671519b0652f3bbe38521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a path with SSL certificates for server identity verification.  <a href="#a7c9fbf7fc9f671519b0652f3bbe38521">More...</a><br /></td></tr>
<tr class="separator:a7c9fbf7fc9f671519b0652f3bbe38521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5f26230279a99fa1429ab84315458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a1bf5f26230279a99fa1429ab84315458">get</a> (const std::string &amp;url)</td></tr>
<tr class="memdesc:a1bf5f26230279a99fa1429ab84315458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a GET request.  <a href="#a1bf5f26230279a99fa1429ab84315458">More...</a><br /></td></tr>
<tr class="separator:a1bf5f26230279a99fa1429ab84315458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b9fe9ff278c5a8cb97125ed3671bb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ab8b9fe9ff278c5a8cb97125ed3671bb3">get</a> (const std::string &amp;url, const std::vector&lt; <a class="el" href="classWt_1_1Http_1_1Message_1_1Header.html">Message::Header</a> &gt; headers)</td></tr>
<tr class="memdesc:ab8b9fe9ff278c5a8cb97125ed3671bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a GET request.  <a href="#ab8b9fe9ff278c5a8cb97125ed3671bb3">More...</a><br /></td></tr>
<tr class="separator:ab8b9fe9ff278c5a8cb97125ed3671bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28336ba9677e6e3cc6c890f490f2965a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a28336ba9677e6e3cc6c890f490f2965a">head</a> (const std::string &amp;url)</td></tr>
<tr class="memdesc:a28336ba9677e6e3cc6c890f490f2965a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a HEAD request.  <a href="#a28336ba9677e6e3cc6c890f490f2965a">More...</a><br /></td></tr>
<tr class="separator:a28336ba9677e6e3cc6c890f490f2965a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fb86c27312b38145c90e47e72153af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a47fb86c27312b38145c90e47e72153af">head</a> (const std::string &amp;url, const std::vector&lt; <a class="el" href="classWt_1_1Http_1_1Message_1_1Header.html">Message::Header</a> &gt; headers)</td></tr>
<tr class="memdesc:a47fb86c27312b38145c90e47e72153af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a HEAD request.  <a href="#a47fb86c27312b38145c90e47e72153af">More...</a><br /></td></tr>
<tr class="separator:a47fb86c27312b38145c90e47e72153af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5cad895252510ff1cd0e8e6e31c453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a2b5cad895252510ff1cd0e8e6e31c453">post</a> (const std::string &amp;url, const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:a2b5cad895252510ff1cd0e8e6e31c453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a POST request.  <a href="#a2b5cad895252510ff1cd0e8e6e31c453">More...</a><br /></td></tr>
<tr class="separator:a2b5cad895252510ff1cd0e8e6e31c453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec02e13a1436a6ab0eb7707681730e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a7ec02e13a1436a6ab0eb7707681730e7">put</a> (const std::string &amp;url, const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:a7ec02e13a1436a6ab0eb7707681730e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a PUT request.  <a href="#a7ec02e13a1436a6ab0eb7707681730e7">More...</a><br /></td></tr>
<tr class="separator:a7ec02e13a1436a6ab0eb7707681730e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbed44b0b94e5a5c9cedc793609fc817"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#afbed44b0b94e5a5c9cedc793609fc817">deleteRequest</a> (const std::string &amp;url, const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:afbed44b0b94e5a5c9cedc793609fc817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a DELETE request.  <a href="#afbed44b0b94e5a5c9cedc793609fc817">More...</a><br /></td></tr>
<tr class="separator:afbed44b0b94e5a5c9cedc793609fc817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cd8725e2af030be90c207d19c05493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a54cd8725e2af030be90c207d19c05493">patch</a> (const std::string &amp;url, const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:a54cd8725e2af030be90c207d19c05493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a PATCH request.  <a href="#a54cd8725e2af030be90c207d19c05493">More...</a><br /></td></tr>
<tr class="separator:a54cd8725e2af030be90c207d19c05493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed50841f6c792d8f08e44225401abab0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0">request</a> (<a class="el" href="namespaceWt_1_1Http.html#a4a1e30eb403b05b4e5afc5c6286dd6b9">Http::Method</a> method, const std::string &amp;url, const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;message)</td></tr>
<tr class="memdesc:aed50841f6c792d8f08e44225401abab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a request.  <a href="#aed50841f6c792d8f08e44225401abab0">More...</a><br /></td></tr>
<tr class="separator:aed50841f6c792d8f08e44225401abab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a756dec030880f02bb3411469c737e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ac2a756dec030880f02bb3411469c737e">abort</a> ()</td></tr>
<tr class="memdesc:ac2a756dec030880f02bb3411469c737e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the curent request.  <a href="#ac2a756dec030880f02bb3411469c737e">More...</a><br /></td></tr>
<tr class="separator:ac2a756dec030880f02bb3411469c737e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad288d9121ba7d6f7dd1e29c9ed2a627d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt; Wt::AsioWrapper::error_code, <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d">done</a> ()</td></tr>
<tr class="memdesc:ad288d9121ba7d6f7dd1e29c9ed2a627d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that is emitted when the current request is done.  <a href="#ad288d9121ba7d6f7dd1e29c9ed2a627d">More...</a><br /></td></tr>
<tr class="separator:ad288d9121ba7d6f7dd1e29c9ed2a627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad874b0869cb2202f6cd2b79e3956773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt; <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#aad874b0869cb2202f6cd2b79e3956773">headersReceived</a> ()</td></tr>
<tr class="memdesc:aad874b0869cb2202f6cd2b79e3956773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that is emitted when all response headers have been received.  <a href="#aad874b0869cb2202f6cd2b79e3956773">More...</a><br /></td></tr>
<tr class="separator:aad874b0869cb2202f6cd2b79e3956773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c75cf826d9918ad4dc200eadd8be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a391c75cf826d9918ad4dc200eadd8be3">bodyDataReceived</a> ()</td></tr>
<tr class="memdesc:a391c75cf826d9918ad4dc200eadd8be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that is emitted when more body data was received.  <a href="#a391c75cf826d9918ad4dc200eadd8be3">More...</a><br /></td></tr>
<tr class="separator:a391c75cf826d9918ad4dc200eadd8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bc95c42292f3fd7d6e54f86b3781b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a34bc95c42292f3fd7d6e54f86b3781b6">followRedirect</a> () const</td></tr>
<tr class="memdesc:a34bc95c42292f3fd7d6e54f86b3781b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the client will follow redirects.  <a href="#a34bc95c42292f3fd7d6e54f86b3781b6">More...</a><br /></td></tr>
<tr class="separator:a34bc95c42292f3fd7d6e54f86b3781b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abede092c50845c4d6f788dde19dc9898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#abede092c50845c4d6f788dde19dc9898">setFollowRedirect</a> (bool <a class="el" href="classWt_1_1Http_1_1Client.html#a34bc95c42292f3fd7d6e54f86b3781b6">followRedirect</a>)</td></tr>
<tr class="memdesc:abede092c50845c4d6f788dde19dc9898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the client will follow redirects.  <a href="#abede092c50845c4d6f788dde19dc9898">More...</a><br /></td></tr>
<tr class="separator:abede092c50845c4d6f788dde19dc9898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e8fb79cd34391b2c6da2b59fe7f223"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a91e8fb79cd34391b2c6da2b59fe7f223">maxRedirects</a> () const</td></tr>
<tr class="memdesc:a91e8fb79cd34391b2c6da2b59fe7f223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of redirects to follow.  <a href="#a91e8fb79cd34391b2c6da2b59fe7f223">More...</a><br /></td></tr>
<tr class="separator:a91e8fb79cd34391b2c6da2b59fe7f223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269c521c9ff7355b780a3b9056914ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a269c521c9ff7355b780a3b9056914ab0">setMaxRedirects</a> (int <a class="el" href="classWt_1_1Http_1_1Client.html#a91e8fb79cd34391b2c6da2b59fe7f223">maxRedirects</a>)</td></tr>
<tr class="memdesc:a269c521c9ff7355b780a3b9056914ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of redirects to follow.  <a href="#a269c521c9ff7355b780a3b9056914ab0">More...</a><br /></td></tr>
<tr class="separator:a269c521c9ff7355b780a3b9056914ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classWt_1_1WObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classWt_1_1WObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classWt_1_1WObject.html">Wt::WObject</a></td></tr>
<tr class="memitem:a3de0f0baf35f42aa4e77a90d427f2e11 inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top"><a id="a3de0f0baf35f42aa4e77a90d427f2e11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">addChild</a> (std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt; child)</td></tr>
<tr class="memdesc:a3de0f0baf35f42aa4e77a90d427f2e11 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a> whose lifetime is determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. <br /></td></tr>
<tr class="separator:a3de0f0baf35f42aa4e77a90d427f2e11 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73777218b9a77b674e15a62d14eab734 inherit pub_methods_classWt_1_1WObject"><td class="memTemplParams" colspan="2">template&lt;typename Child &gt; </td></tr>
<tr class="memitem:a73777218b9a77b674e15a62d14eab734 inherit pub_methods_classWt_1_1WObject"><td class="memTemplItemLeft" align="right" valign="top">Child *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a73777218b9a77b674e15a62d14eab734">addChild</a> (std::unique_ptr&lt; Child &gt; child)</td></tr>
<tr class="memdesc:a73777218b9a77b674e15a62d14eab734 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, returning a raw pointer.  <a href="classWt_1_1WObject.html#a73777218b9a77b674e15a62d14eab734">More...</a><br /></td></tr>
<tr class="separator:a73777218b9a77b674e15a62d14eab734 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d60618c6ca687226a5f1bbf1be6dc4 inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top"><a id="ad1d60618c6ca687226a5f1bbf1be6dc4"></a>
std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#ad1d60618c6ca687226a5f1bbf1be6dc4">removeChild</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *child)</td></tr>
<tr class="memdesc:ad1d60618c6ca687226a5f1bbf1be6dc4 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. <br /></td></tr>
<tr class="separator:ad1d60618c6ca687226a5f1bbf1be6dc4 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f32a263b742f42b73a9353eaa3c7ca inherit pub_methods_classWt_1_1WObject"><td class="memTemplParams" colspan="2">template&lt;typename Child &gt; </td></tr>
<tr class="memitem:a00f32a263b742f42b73a9353eaa3c7ca inherit pub_methods_classWt_1_1WObject"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Child &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a00f32a263b742f42b73a9353eaa3c7ca">removeChild</a> (Child *child)</td></tr>
<tr class="memdesc:a00f32a263b742f42b73a9353eaa3c7ca inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>.  <a href="classWt_1_1WObject.html#a00f32a263b742f42b73a9353eaa3c7ca">More...</a><br /></td></tr>
<tr class="separator:a00f32a263b742f42b73a9353eaa3c7ca inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34b0c9ec343cf467f8b237d3256792 inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a9f34b0c9ec343cf467f8b237d3256792">id</a> () const</td></tr>
<tr class="memdesc:a9f34b0c9ec343cf467f8b237d3256792 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (unique) identifier for this object.  <a href="classWt_1_1WObject.html#a9f34b0c9ec343cf467f8b237d3256792">More...</a><br /></td></tr>
<tr class="separator:a9f34b0c9ec343cf467f8b237d3256792 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875fda02eff6260ab665647f7215e262 inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262">setObjectName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a875fda02eff6260ab665647f7215e262 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an object name.  <a href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262">More...</a><br /></td></tr>
<tr class="separator:a875fda02eff6260ab665647f7215e262 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aedaccd24488c182912782de70ce2d inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a73aedaccd24488c182912782de70ce2d">objectName</a> () const</td></tr>
<tr class="memdesc:a73aedaccd24488c182912782de70ce2d inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object name.  <a href="classWt_1_1WObject.html#a73aedaccd24488c182912782de70ce2d">More...</a><br /></td></tr>
<tr class="separator:a73aedaccd24488c182912782de70ce2d inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d8b00edc79b7a60d41d7c088f50436 inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436">resetLearnedSlots</a> ()</td></tr>
<tr class="memdesc:a92d8b00edc79b7a60d41d7c088f50436 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets learned stateless slot implementations.  <a href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436">More...</a><br /></td></tr>
<tr class="separator:a92d8b00edc79b7a60d41d7c088f50436 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7dcd5a60c88e5b36f0c8e0f9117698 inherit pub_methods_classWt_1_1WObject"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5c7dcd5a60c88e5b36f0c8e0f9117698 inherit pub_methods_classWt_1_1WObject"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698">resetLearnedSlot</a> (void(T::*method)())</td></tr>
<tr class="memdesc:a5c7dcd5a60c88e5b36f0c8e0f9117698 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a learned stateless slot implementation.  <a href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698">More...</a><br /></td></tr>
<tr class="separator:a5c7dcd5a60c88e5b36f0c8e0f9117698 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa163b9e92933f3b2ff4ec58e2734c6 inherit pub_methods_classWt_1_1WObject"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adaa163b9e92933f3b2ff4ec58e2734c6 inherit pub_methods_classWt_1_1WObject"><td class="memTemplItemLeft" align="right" valign="top">WStatelessSlot *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless</a> (void(T::*method)())</td></tr>
<tr class="memdesc:adaa163b9e92933f3b2ff4ec58e2734c6 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a slot to be stateless and learn client-side behaviour on first invocation.  <a href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">More...</a><br /></td></tr>
<tr class="separator:adaa163b9e92933f3b2ff4ec58e2734c6 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf46fd1437f07150a9dd95bd95c266d inherit pub_methods_classWt_1_1WObject"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bf46fd1437f07150a9dd95bd95c266d inherit pub_methods_classWt_1_1WObject"><td class="memTemplItemLeft" align="right" valign="top">WStatelessSlot *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a7bf46fd1437f07150a9dd95bd95c266d">implementStateless</a> (void(T::*method)(), void(T::*undoMethod)())</td></tr>
<tr class="memdesc:a7bf46fd1437f07150a9dd95bd95c266d inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a slot to be stateless and learn client-side behaviour in advance.  <a href="classWt_1_1WObject.html#a7bf46fd1437f07150a9dd95bd95c266d">More...</a><br /></td></tr>
<tr class="separator:a7bf46fd1437f07150a9dd95bd95c266d inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dde4ce1e833a9966709daf3c0dedc9f inherit pub_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a6dde4ce1e833a9966709daf3c0dedc9f">isNotStateless</a> ()</td></tr>
<tr class="memdesc:a6dde4ce1e833a9966709daf3c0dedc9f inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the current function as not stateless.  <a href="classWt_1_1WObject.html#a6dde4ce1e833a9966709daf3c0dedc9f">More...</a><br /></td></tr>
<tr class="separator:a6dde4ce1e833a9966709daf3c0dedc9f inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214deee5d7324b9afd4ce44534daa782 inherit pub_methods_classWt_1_1WObject"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a214deee5d7324b9afd4ce44534daa782 inherit pub_methods_classWt_1_1WObject"><td class="memTemplItemLeft" align="right" valign="top">WStatelessSlot *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a214deee5d7324b9afd4ce44534daa782">implementJavaScript</a> (void(T::*method)(), const std::string &amp;jsCode)</td></tr>
<tr class="memdesc:a214deee5d7324b9afd4ce44534daa782 inherit pub_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a JavaScript implementation for a method.  <a href="classWt_1_1WObject.html#a214deee5d7324b9afd4ce44534daa782">More...</a><br /></td></tr>
<tr class="separator:a214deee5d7324b9afd4ce44534daa782 inherit pub_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classWt_1_1Core_1_1observable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classWt_1_1Core_1_1observable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classWt_1_1Core_1_1observable.html">Wt::Core::observable</a></td></tr>
<tr class="memitem:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="ac18aee9da79a11ad8492ed5e95ed52e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#ac18aee9da79a11ad8492ed5e95ed52e4">observable</a> () noexcept</td></tr>
<tr class="memdesc:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#aaff32cdbd6cd167b3e384f0d7ee7d0b8">~observable</a> ()</td></tr>
<tr class="memdesc:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classWt_1_1Core_1_1observable.html#aaff32cdbd6cd167b3e384f0d7ee7d0b8">More...</a><br /></td></tr>
<tr class="separator:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename C &gt; </td></tr>
<tr class="memitem:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#a836dedaeb83d6002de00d6ac2a5b0315">bindSafe</a> (void(C::*method)(Args...)) noexcept</td></tr>
<tr class="memdesc:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects a method call against object destruction.  <a href="classWt_1_1Core_1_1observable.html#a836dedaeb83d6002de00d6ac2a5b0315">More...</a><br /></td></tr>
<tr class="separator:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename C &gt; </td></tr>
<tr class="memitem:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#aaae8420328720c8b37c31613dda586ad">bindSafe</a> (void(C::*method)(Args...) const) const noexcept</td></tr>
<tr class="memdesc:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects a const method call against object destruction.  <a href="classWt_1_1Core_1_1observable.html#aaae8420328720c8b37c31613dda586ad">More...</a><br /></td></tr>
<tr class="separator:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#a8f17f1b96a1a3967f4c6c30150c95d58">bindSafe</a> (const Function &amp;function) noexcept</td></tr>
<tr class="memdesc:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects a function against object destruction.  <a href="classWt_1_1Core_1_1observable.html#a8f17f1b96a1a3967f4c6c30150c95d58">More...</a><br /></td></tr>
<tr class="separator:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4637aff36362649ce8c9dddc6118fd43"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Http_1_1Client.html#a4637aff36362649ce8c9dddc6118fd43">parseUrl</a> (const std::string &amp;url, <a class="el" href="structWt_1_1Http_1_1Client_1_1URL.html">URL</a> &amp;parsedUrl)</td></tr>
<tr class="memdesc:a4637aff36362649ce8c9dddc6118fd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to parse a URL.  <a href="#a4637aff36362649ce8c9dddc6118fd43">More...</a><br /></td></tr>
<tr class="separator:a4637aff36362649ce8c9dddc6118fd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classWt_1_1WObject"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classWt_1_1WObject')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classWt_1_1WObject.html">Wt::WObject</a></td></tr>
<tr class="memitem:aec904644d278b09d3f7e568fd2efd400 inherit pub_types_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top"><a id="aec904644d278b09d3f7e568fd2efd400"></a>
typedef void(WObject::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a>) ()</td></tr>
<tr class="memdesc:aec904644d278b09d3f7e568fd2efd400 inherit pub_types_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a WObject method without arguments. <br /></td></tr>
<tr class="separator:aec904644d278b09d3f7e568fd2efd400 inherit pub_types_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classWt_1_1WObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classWt_1_1WObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classWt_1_1WObject.html">Wt::WObject</a></td></tr>
<tr class="memitem:adbed50331d6abf7c19628b3140daa9b4 inherit pro_methods_classWt_1_1WObject"><td class="memItemLeft" align="right" valign="top">virtual WStatelessSlot *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#adbed50331d6abf7c19628b3140daa9b4">getStateless</a> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method)</td></tr>
<tr class="memdesc:adbed50331d6abf7c19628b3140daa9b4 inherit pro_methods_classWt_1_1WObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-demand stateless slot implementation.  <a href="classWt_1_1WObject.html#adbed50331d6abf7c19628b3140daa9b4">More...</a><br /></td></tr>
<tr class="separator:adbed50331d6abf7c19628b3140daa9b4 inherit pro_methods_classWt_1_1WObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An HTTP client. </p>
<p>This class implements an HTTP client. It can be used to interact with web services using the HTTP protocol.</p>
<p>The client uses asynchronous I/O and only provides an asynchronous interface: you cannot actively wait for an operation to complete, instead the client will notify you of the result using the <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> signal.</p>
<p>Because the client uses asynchronous I/O, it does its work within the scope of an event-driven thread pool implementation. By default, this is the same thread pool that is used by the Wt server, available through <a class="el" href="classWt_1_1WServer.html#adf84e177385ff262005a2044daa9c34f" title="Returns the I/O service.">WServer::ioService()</a>, but you may also use the client by providing it an explicit I/O service to be used.</p>
<p>The client supports the HTTP and HTTPS (if Wt was built with OpenSSL support) protocols, and can be used for GET and POST methods. One client can do only one operation at a time.</p>
<p>Usage example: </p><div class="fragment"><div class="line">   ...</div><div class="line">   <span class="keyword">auto</span> client = <a class="code" href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">addChild</a>(std::make_unique&lt;Http::Client&gt;());</div><div class="line">   client-&gt;setTimeout(std::chrono::seconds{15});</div><div class="line">   client-&gt;setMaximumResponseSize(10 * 1024);</div><div class="line">   client-&gt;done().connect(std::bind(&amp;MyWidget::handleHttpResponse, <span class="keyword">this</span>, _1, _2));</div><div class="line">   <span class="keywordflow">if</span> (client-&gt;get(<span class="stringliteral">&quot;http://www.webtoolkit.eu/wt/blog/feed/&quot;</span>))</div><div class="line">     <a class="code" href="classWt_1_1WApplication.html#a0a866fd44045f2e1685790b1c3c4cb41">WApplication::instance</a>()-&gt;<a class="code" href="classWt_1_1WApplication.html#af6a25f56ab9d309d799012faf8823f48">deferRendering</a>();</div><div class="line">   <span class="keywordflow">else</span> {</div><div class="line">     <span class="comment">// in case of an error in the %URL</span></div><div class="line">   }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> handleHttpResponse(std::system::error_code err, <span class="keyword">const</span> Http::Message&amp; response)</div><div class="line">{</div><div class="line">   <a class="code" href="classWt_1_1WApplication.html#a0a866fd44045f2e1685790b1c3c4cb41">WApplication::instance</a>()-&gt;<a class="code" href="classWt_1_1WApplication.html#a62dfa943a37a250ec781e9019ccd7434">resumeRendering</a>();</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (!err &amp;&amp; response.status() == 200) {</div><div class="line">      ... <a class="code" href="group__json.html#ga439195eac280701c9a1e5f0317149866">parse</a> response.body()</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>The function connected to the <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> signal will be run within the context of the application that created the client. <a class="el" href="classWt_1_1WServer.html#a191243d6c9718b18f6e1830562b01806" title="Posts a function to a session.">WServer::post()</a> is used for this.</p>
<h3>Basic access authentication</h3>
<p>When you want to add authentication information in the URL, this can be done as <code><a href="https://username:password@www.example.com/">https://username:password@www.example.com/</a></code>. When doing this, make sure that the username and password string are URL-encoded (<a class="el" href="namespaceWt_1_1Utils.html#a1b4b24d924ef0162777045451f2fc09b">Wt::Utils::urlEncode</a>). For example, <code><a href="https://username:pass">https://username:pass</a> <a href="#" onclick="location.href='mai'+'lto:'+'wor'+'d@'+'www'+'.e'+'xam'+'pl'+'e.c'+'om'; return false;">word@<span style="display: none;">.nosp@m.</span>www.<span style="display: none;">.nosp@m.</span>examp<span style="display: none;">.nosp@m.</span>le.c<span style="display: none;">.nosp@m.</span>om</a>/</code> should be passed as <code><a href="https://username:pass%20word@www.example.com/">https://username:pass%20word@www.example.com/</a></code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab850f51173c33a12ec3d4b3371e7d1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab850f51173c33a12ec3d4b3371e7d1b0">&#9670;&nbsp;</a></span>Client() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wt::Http::Client::Client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The client uses the I/O service and thread-pool from the current <a class="el" href="classWt_1_1WApplication.html#a0a866fd44045f2e1685790b1c3c4cb41" title="Returns the current application instance.">WApplication::instance()</a>. </p>

</div>
</div>
<a id="a966378bd63f2babf2f8d2beb2783e45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966378bd63f2babf2f8d2beb2783e45e">&#9670;&nbsp;</a></span>Client() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Wt::Http::Client::Client </td>
          <td>(</td>
          <td class="paramtype">Wt::AsioWrapper::asio::io_service &amp;&#160;</td>
          <td class="paramname"><em>ioService</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>The client uses the given I/O service and thread-pool, and is useful to use the client outside the context of a web application. </p>

</div>
</div>
<a id="abee67605e85d941cd9726da986b26532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee67605e85d941cd9726da986b26532">&#9670;&nbsp;</a></span>~Client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Wt::Http::Client::~Client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If the client is still busy, the current request is aborted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#ac2a756dec030880f02bb3411469c737e" title="Aborts the curent request.">abort()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2a756dec030880f02bb3411469c737e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a756dec030880f02bb3411469c737e">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the curent request. </p>
<p>If the client is currently busy, this cancels the pending request. <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted with asio::error::operation_aborted.</p>
<dl class="section note"><dt>Note</dt><dd>The abort will be performed asynchronously, so it is possible that <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> is still emitted with a successful response after <a class="el" href="classWt_1_1Http_1_1Client.html#ac2a756dec030880f02bb3411469c737e" title="Aborts the curent request.">abort()</a> is called. </dd></dl>

</div>
</div>
<a id="a391c75cf826d9918ad4dc200eadd8be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c75cf826d9918ad4dc200eadd8be3">&#9670;&nbsp;</a></span>bodyDataReceived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt;std::string&gt;&amp; Wt::Http::Client::bodyDataReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal that is emitted when more body data was received. </p>
<p>The signal contains the next body data chunk received. You may want to catch this signal if you want to process the response as it is being received.</p>
<p>You may want to use this in combination with setMaximumResponseSize(0) to handle very long responses. </p>

</div>
</div>
<a id="afbed44b0b94e5a5c9cedc793609fc817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbed44b0b94e5a5c9cedc793609fc817">&#9670;&nbsp;</a></span>deleteRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::deleteRequest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a DELETE request. </p>
<p>The function starts an asynchronous DELETE request, and returns immediately.</p>
<p>The function returns <code>true</code> when the DELETE request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="ad288d9121ba7d6f7dd1e29c9ed2a627d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad288d9121ba7d6f7dd1e29c9ed2a627d">&#9670;&nbsp;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt;Wt::AsioWrapper::error_code, <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a>&gt;&amp; Wt::Http::Client::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal that is emitted when the current request is done. </p>
<p>The <code>error</code> is 0 if the HTTP request was successful. Then, the <code>message</code> contains the result.</p>
<p>If the <code>error</code> is not 0, then an error message is given by <code>err.message()</code>.</p>
<p>Typical code to process the result is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> handle(Wt::AsioWrapper::error_code err, <span class="keyword">const</span> Http::Message&amp; response)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!err) {</div><div class="line">    <span class="keywordflow">if</span> (response.status() == 200) {</div><div class="line">      ... success</div><div class="line">    }</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    Wt::log(<span class="stringliteral">&quot;error&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Http::Client error: &quot;</span> &lt;&lt; err.message();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a34bc95c42292f3fd7d6e54f86b3781b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bc95c42292f3fd7d6e54f86b3781b6">&#9670;&nbsp;</a></span>followRedirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::followRedirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the client will follow redirects. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#abede092c50845c4d6f788dde19dc9898" title="Set whether the client will follow redirects.">setFollowRedirect</a> </dd></dl>

</div>
</div>
<a id="a1bf5f26230279a99fa1429ab84315458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf5f26230279a99fa1429ab84315458">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a GET request. </p>
<p>The function starts an asynchronous GET request, and returns immediately.</p>
<p>The function returns <code>true</code> when the GET request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="ab8b9fe9ff278c5a8cb97125ed3671bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b9fe9ff278c5a8cb97125ed3671bb3">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classWt_1_1Http_1_1Message_1_1Header.html">Message::Header</a> &gt;&#160;</td>
          <td class="paramname"><em>headers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a GET request. </p>
<p>The function starts an asynchronous GET request, and returns immediately.</p>
<p>The function returns <code>true</code> when the GET request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<p>This function accepts one or more headers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="a28336ba9677e6e3cc6c890f490f2965a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28336ba9677e6e3cc6c890f490f2965a">&#9670;&nbsp;</a></span>head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::head </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a HEAD request. </p>
<p>The function starts an asynchronous HEAD request, and returns immediately.</p>
<p>The function returns <code>true</code> when the HEAD request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="a47fb86c27312b38145c90e47e72153af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fb86c27312b38145c90e47e72153af">&#9670;&nbsp;</a></span>head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::head </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classWt_1_1Http_1_1Message_1_1Header.html">Message::Header</a> &gt;&#160;</td>
          <td class="paramname"><em>headers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a HEAD request. </p>
<p>The function starts an asynchronous HEAD request, and returns immediately.</p>
<p>The function returns <code>true</code> when the HEAD request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<p>This function accepts one or more headers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="aad874b0869cb2202f6cd2b79e3956773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad874b0869cb2202f6cd2b79e3956773">&#9670;&nbsp;</a></span>headersReceived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Signal.html">Signal</a>&lt;<a class="el" href="classWt_1_1Http_1_1Message.html">Message</a>&gt;&amp; Wt::Http::Client::headersReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal that is emitted when all response headers have been received. </p>
<p>The signal forwards the message with all headers, but with empty body text. You may want to catch this signal if you want to examine the headers prior to having received the complete message.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#a391c75cf826d9918ad4dc200eadd8be3" title="Signal that is emitted when more body data was received.">bodyDataReceived()</a> </dd></dl>

</div>
</div>
<a id="ae683fec0c7c53aa39085c3455a9ba519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae683fec0c7c53aa39085c3455a9ba519">&#9670;&nbsp;</a></span>isSslCertificateVerificationEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::isSslCertificateVerificationEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether SSL certificate verification is enabled. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#a54355849e1235697747eb0361eb643dd" title="Enables SSL certificate verification.">setSslCertificateVerificationEnabled()</a> </dd></dl>

</div>
</div>
<a id="ab8d6c65425f43fb373e4b66860033d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d6c65425f43fb373e4b66860033d31">&#9670;&nbsp;</a></span>maximumResponseSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Wt::Http::Client::maximumResponseSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum response size. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#a45b25de10c5da7c7c5abf0892593a04d" title="Sets a maximum response size.">setMaximumResponseSize()</a> </dd></dl>

</div>
</div>
<a id="a91e8fb79cd34391b2c6da2b59fe7f223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e8fb79cd34391b2c6da2b59fe7f223">&#9670;&nbsp;</a></span>maxRedirects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Wt::Http::Client::maxRedirects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of redirects to follow. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#a269c521c9ff7355b780a3b9056914ab0" title="Set the maximum number of redirects to follow.">setMaxRedirects()</a> </dd></dl>

</div>
</div>
<a id="a4637aff36362649ce8c9dddc6118fd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4637aff36362649ce8c9dddc6118fd43">&#9670;&nbsp;</a></span>parseUrl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Wt::Http::Client::parseUrl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWt_1_1Http_1_1Client_1_1URL.html">URL</a> &amp;&#160;</td>
          <td class="paramname"><em>parsedUrl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method to parse a URL. </p>
<p>This parses a URL into an <a class="el" href="structWt_1_1Http_1_1Client_1_1URL.html" title="Utility class representing an URL.">URL</a> object.</p>
<p>The method returns true if the URL could be parsed successfully. </p>

</div>
</div>
<a id="a54cd8725e2af030be90c207d19c05493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cd8725e2af030be90c207d19c05493">&#9670;&nbsp;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::patch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a PATCH request. </p>
<p>The function starts an asynchronous PATCH request, and returns immediately.</p>
<p>The function returns <code>true</code> when the PATCH request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="a2b5cad895252510ff1cd0e8e6e31c453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5cad895252510ff1cd0e8e6e31c453">&#9670;&nbsp;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::post </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a POST request. </p>
<p>The function starts an asynchronous POST request, and returns immediately.</p>
<p>The function returns <code>true</code> when the POST request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="a7ec02e13a1436a6ab0eb7707681730e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec02e13a1436a6ab0eb7707681730e7">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::put </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a PUT request. </p>
<p>The function starts an asynchronous PUT request, and returns immediately.</p>
<p>The function returns <code>true</code> when the PUT request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="aed50841f6c792d8f08e44225401abab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed50841f6c792d8f08e44225401abab0">&#9670;&nbsp;</a></span>request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Wt::Http::Client::request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWt_1_1Http.html#a4a1e30eb403b05b4e5afc5c6286dd6b9">Http::Method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Http_1_1Message.html">Message</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a request. </p>
<p>The function starts an asynchronous HTTP request, and returns immediately.</p>
<p>The function returns <code>true</code> when the request has been scheduled, and thus <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> will be emitted eventually.</p>
<p>The function returns <code>false</code> if the client could not schedule the request, for example if the <code>url</code> is invalid or if the URL scheme is not supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#aed50841f6c792d8f08e44225401abab0" title="Starts a request.">request()</a>, <a class="el" href="classWt_1_1Http_1_1Client.html#ad288d9121ba7d6f7dd1e29c9ed2a627d" title="Signal that is emitted when the current request is done.">done()</a> </dd></dl>

</div>
</div>
<a id="abede092c50845c4d6f788dde19dc9898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abede092c50845c4d6f788dde19dc9898">&#9670;&nbsp;</a></span>setFollowRedirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setFollowRedirect </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>followRedirect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the client will follow redirects. </p>
<p>If set and the request method is GET, redirects are automatically followed. </p>

</div>
</div>
<a id="a45b25de10c5da7c7c5abf0892593a04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b25de10c5da7c7c5abf0892593a04d">&#9670;&nbsp;</a></span>setMaximumResponseSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setMaximumResponseSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a maximum response size. </p>
<p>The response is stored in-memory. To avoid a DoS by a malicious downstream HTTP server, the response size is bounded by an upper limit.</p>
<p>The limit includes status line, headers and response body.</p>
<p>The default value is 64 kilo bytes.</p>
<p>A value of 0 has a special meaning: the size of the response will not be limited, but the response body will not be stored in the response message. Instead the data is made available only to <a class="el" href="classWt_1_1Http_1_1Client.html#a391c75cf826d9918ad4dc200eadd8be3" title="Signal that is emitted when more body data was received.">bodyDataReceived()</a> to be processed incrementally. </p>

</div>
</div>
<a id="a269c521c9ff7355b780a3b9056914ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269c521c9ff7355b780a3b9056914ab0">&#9670;&nbsp;</a></span>setMaxRedirects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setMaxRedirects </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRedirects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of redirects to follow. </p>
<p>This is used only when <a class="el" href="classWt_1_1Http_1_1Client.html#a34bc95c42292f3fd7d6e54f86b3781b6" title="Returns whether the client will follow redirects.">followRedirect()</a> is enabled.</p>
<p>The default is 20. </p>

</div>
</div>
<a id="a54355849e1235697747eb0361eb643dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54355849e1235697747eb0361eb643dd">&#9670;&nbsp;</a></span>setSslCertificateVerificationEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setSslCertificateVerificationEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables SSL certificate verification. </p>
<p>For https requests, it is (very strongly!) recommended to perform certificate verification: this verifies that you are indeed connected to the server you intended (and not to a man-in-the-middle). Without such a check, encryption simply isn't very useful.</p>
<p>Nevertheless, there may be situations in which you will want to disable this functionality.</p>
<p>The default configuration is to have certificate verification enabled. </p>

</div>
</div>
<a id="ac6b8b35ab2813a22c3c2e2ae7d1f9a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b8b35ab2813a22c3c2e2ae7d1f9a35">&#9670;&nbsp;</a></span>setSslVerifyFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setSslVerifyFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>verifyFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a SSL certificate used for server identity verification. </p>
<p>This setting only affects a https request: it configures a certificate file to be used to verify the identity of the server. </p>

</div>
</div>
<a id="a7c9fbf7fc9f671519b0652f3bbe38521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9fbf7fc9f671519b0652f3bbe38521">&#9670;&nbsp;</a></span>setSslVerifyPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setSslVerifyPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>verifyPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a path with SSL certificates for server identity verification. </p>
<p>This setting only affects a https request: it configures a directory containing certificates to be used to verify the identity of the server. </p>

</div>
</div>
<a id="a3d8f9647e25c264cd9296a61aba16753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8f9647e25c264cd9296a61aba16753">&#9670;&nbsp;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::Http::Client::setTimeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::steady_clock::duration&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an I/O timeout. </p>
<p>This sets a timeout waiting for I/O operations. The timeout does not bound the total timeout, since the timer is reset on each I/O progress.</p>
<p>The default timeout is 10 seconds. </p>

</div>
</div>
<a id="ab98a080e1ae3a5d0e09ab0fca76a43ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98a080e1ae3a5d0e09ab0fca76a43ea">&#9670;&nbsp;</a></span>timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::steady_clock::duration Wt::Http::Client::timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the I/O timeout. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Http_1_1Client.html#a3d8f9647e25c264cd9296a61aba16753" title="Sets an I/O timeout.">setTimeout()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><address style="text-align: right; margin: 3px"><small>
Generated on Wed Apr 22 2020 for <a href="http://www.webtoolkit.eu/wt">the
C++ Web Toolkit (Wt)</a> by&nbsp;<a
href="http://www.doxygen.org/index.html"><img src="doxygen.png"
alt="doxygen" border="0" style="vertical-align: middle; display:
inline-block; height: 2em"></a> 1.8.15</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wt: Wt::WObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wt
   &#160;<span id="projectnumber">4.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWt.html">Wt</a></li><li class="navelem"><a class="el" href="classWt_1_1WObject.html">WObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classWt_1_1WObject-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wt::WObject Class Reference<div class="ingroups"><a class="el" href="group__signalslot.html">Signal/slot system</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A base class for objects that participate in the signal/slot system.  
 <a href="classWt_1_1WObject.html#details">More...</a></p>

<p><code>#include &lt;Wt/WObject.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Wt::WObject:</div>
<div class="dyncontent">
<div class="center"><img src="classWt_1_1WObject__inherit__graph.png" border="0" usemap="#Wt_1_1WObject_inherit__map" alt="Inheritance graph"/></div>
<map name="Wt_1_1WObject_inherit__map" id="Wt_1_1WObject_inherit__map">
<area shape="rect"  title="A base class for objects that participate in the signal/slot system." alt="" coords="196,753,295,780"/>
<area shape="rect"  href="classWt_1_1Auth_1_1Login.html" title="A class that manages the current login state." alt="" coords="387,5,501,32"/>
<area shape="rect"  href="classWt_1_1Auth_1_1OAuthAuthorizationEndpointProcess.html" title="Allows clients to authorize users according to the OAuth 2.0 protocol." alt="" coords="347,57,541,98"/>
<area shape="rect"  href="classWt_1_1Auth_1_1OAuthProcess.html" title="An OAuth authorization (and authentication) process." alt="" coords="361,123,527,149"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WAbstractChartModel.html" title="An abstract model for use with Wt&#39;s charts." alt="" coords="355,174,533,215"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WAbstractColorMap.html" title="Maps numerical values to colors." alt="" coords="343,240,545,267"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WAbstractDataSeries3D.html" title="Abstract base class for dataseries that can be drawn on a WCartesian3DChart." alt="" coords="357,291,531,333"/>
<area shape="rect"  href="classWt_1_1Http_1_1Client.html" title="An HTTP client." alt="" coords="388,357,500,384"/>
<area shape="rect"  href="classWt_1_1Payment_1_1PayPalExpressCheckout.html" title="A paypal express checkout process." alt="" coords="345,409,543,450"/>
<area shape="rect"  href="classWt_1_1WAbstractArea.html" title="Abstract base class for interactive areas in a widget." alt="" coords="376,475,512,501"/>
<area shape="rect"  href="classWt_1_1WAbstractItemDelegate.html" title="Abstract delegate class for rendering an item in an item view." alt="" coords="351,525,537,552"/>
<area shape="rect"  href="classWt_1_1WAbstractItemModel.html" title="An abstract model for use with Wt&#39;s view classes." alt="" coords="359,576,529,603"/>
<area shape="rect"  href="classWt_1_1WApplication.html" title="Represents an application instance for a single session." alt="" coords="382,627,506,653"/>
<area shape="rect"  href="classWt_1_1WButtonGroup.html" title="A class for grouping radio buttons logically together." alt="" coords="377,677,511,704"/>
<area shape="rect"  href="classWt_1_1WCanvasPaintDevice.html" title="A paint device for rendering using the HTML 5 &lt;canvas&gt; element." alt="" coords="359,728,529,755"/>
<area shape="rect"  href="classWt_1_1WCssDecorationStyle.html" title="A style class for a single widget or style sheet rule." alt="" coords="357,779,531,805"/>
<area shape="rect"  href="classWt_1_1WCssRule.html" title="Abstract rule in a CSS style sheet." alt="" coords="389,829,499,856"/>
<area shape="rect"  href="classWt_1_1WFileDropWidget_1_1File.html" title="A nested class of WFileDropWidget representing a file." alt="" coords="369,881,519,922"/>
<area shape="rect"  href="classWt_1_1WFormModel.html" title="A basic model class for forms." alt="" coords="381,947,507,973"/>
<area shape="rect"  href="classWt_1_1WItemSelectionModel.html" title="A class that represents a selection for a WAbstractItemView." alt="" coords="357,997,531,1024"/>
<area shape="rect"  href="classWt_1_1WLayout.html" title="An abstract base class for layout managers." alt="" coords="395,1048,493,1075"/>
<area shape="rect"  href="classWt_1_1WResource.html" title="An object which can be rendered in the HTTP protocol." alt="" coords="387,1099,501,1125"/>
<area shape="rect"  href="classWt_1_1WSocketNotifier.html" title="A utility class for asynchronous notification of socket activity." alt="" coords="373,1149,515,1176"/>
<area shape="rect"  href="classWt_1_1WSound.html" title="A value class to play a sound effect." alt="" coords="395,1200,493,1227"/>
<area shape="rect"  href="classWt_1_1WTableColumn.html" title="A table column." alt="" coords="377,1251,511,1277"/>
<area shape="rect"  href="classWt_1_1WTableRow.html" title="A table row." alt="" coords="386,1301,502,1328"/>
<area shape="rect"  href="classWt_1_1WTheme.html" title=" " alt="" coords="395,1352,493,1379"/>
<area shape="rect"  href="classWt_1_1WTimer.html" title="A utility class which provides timer signals and single&#45;shot timers." alt="" coords="398,1403,490,1429"/>
<area shape="rect"  href="classWt_1_1WWidget.html" title="The abstract base class for a user&#45;interface component." alt="" coords="393,1453,495,1480"/>
<area shape="rect"  href="classWt_1_1Core_1_1observable.html" title="A base class for objects whose life&#45;time can be tracked." alt="" coords="5,753,148,780"/>
<area shape="rect"  href="classWt_1_1Auth_1_1OidcProcess.html" title="An OpenId Connect authentication process." alt="" coords="618,104,775,131"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WStandardChartProxyModel.html" title="A WAbstractChartModel implementation that wraps a WAbstractItemModel." alt="" coords="605,155,788,197"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WStandardColorMap.html" title="Standard colorMap." alt="" coords="593,221,800,248"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WAbstractGridData.html" title="Class representing grid&#45;based data for on a 3D chart." alt="" coords="597,272,796,299"/>
<area shape="rect"  href="classWt_1_1Chart_1_1WScatterData.html" title="Class representing a collection of points for on a 3D chart." alt="" coords="613,323,781,349"/>
<area shape="rect"  href="classWt_1_1WCircleArea.html" title="A interactive area in a widget, specified by a circle." alt="" coords="637,373,757,400"/>
<area shape="rect"  href="classWt_1_1WPolygonArea.html" title="An interactive area in a widget, specified by a polygon." alt="" coords="629,424,764,451"/>
<area shape="rect"  href="classWt_1_1WRectArea.html" title="A interactive area in a widget, specified by a rectangle." alt="" coords="639,475,754,501"/>
<area shape="rect"  href="classWt_1_1WItemDelegate.html" title="Standard delegate class for rendering a view item." alt="" coords="629,525,765,552"/>
<area shape="rect"  href="classWt_1_1WAbstractListModel.html" title="An abstract list model for use with Wt&#39;s view classes." alt="" coords="614,576,779,603"/>
<area shape="rect"  href="classWt_1_1WAbstractProxyModel.html" title="An abstract proxy model for Wt&#39;s item models." alt="" coords="607,627,786,653"/>
<area shape="rect"  href="classWt_1_1WAbstractTableModel.html" title="An abstract table model for use with Wt&#39;s view classes." alt="" coords="609,677,784,704"/>
<area shape="rect"  href="classWt_1_1WStandardItemModel.html" title="A standard data model, which stores its data in memory." alt="" coords="611,728,783,755"/>
<area shape="rect"  href="classWt_1_1WCssTemplateRule.html" title="A CSS rule based on a template widget." alt="" coords="615,804,778,831"/>
<area shape="rect"  href="classWt_1_1WCssTextRule.html" title="A CSS rule specified directly using CSS declarations." alt="" coords="629,855,764,881"/>
<area shape="rect"  href="classWt_1_1Auth_1_1FormBaseModel.html" title="A base model class for authentication&#45;related forms." alt="" coords="608,947,785,973"/>
<area shape="rect"  href="classWt_1_1WBorderLayout.html" title="A layout manager which divides the container region in five regions." alt="" coords="628,997,765,1024"/>
<area shape="rect"  href="classWt_1_1WBoxLayout.html" title="A layout manager which arranges widgets horizontally or vertically." alt="" coords="635,1048,758,1075"/>
<area shape="rect"  href="classWt_1_1WFitLayout.html" title="A layout manager which spans a single widget to all available space." alt="" coords="639,1099,754,1125"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aec904644d278b09d3f7e568fd2efd400"><td class="memItemLeft" align="right" valign="top"><a id="aec904644d278b09d3f7e568fd2efd400"></a>
typedef void(WObject::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a>) ()</td></tr>
<tr class="memdesc:aec904644d278b09d3f7e568fd2efd400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a WObject method without arguments. <br /></td></tr>
<tr class="separator:aec904644d278b09d3f7e568fd2efd400"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3de0f0baf35f42aa4e77a90d427f2e11"><td class="memItemLeft" align="right" valign="top"><a id="a3de0f0baf35f42aa4e77a90d427f2e11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">addChild</a> (std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt; child)</td></tr>
<tr class="memdesc:a3de0f0baf35f42aa4e77a90d427f2e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a> whose lifetime is determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. <br /></td></tr>
<tr class="separator:a3de0f0baf35f42aa4e77a90d427f2e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73777218b9a77b674e15a62d14eab734"><td class="memTemplParams" colspan="2">template&lt;typename Child &gt; </td></tr>
<tr class="memitem:a73777218b9a77b674e15a62d14eab734"><td class="memTemplItemLeft" align="right" valign="top">Child *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a73777218b9a77b674e15a62d14eab734">addChild</a> (std::unique_ptr&lt; Child &gt; child)</td></tr>
<tr class="memdesc:a73777218b9a77b674e15a62d14eab734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, returning a raw pointer.  <a href="#a73777218b9a77b674e15a62d14eab734">More...</a><br /></td></tr>
<tr class="separator:a73777218b9a77b674e15a62d14eab734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d60618c6ca687226a5f1bbf1be6dc4"><td class="memItemLeft" align="right" valign="top"><a id="ad1d60618c6ca687226a5f1bbf1be6dc4"></a>
std::unique_ptr&lt; <a class="el" href="classWt_1_1WObject.html">WObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#ad1d60618c6ca687226a5f1bbf1be6dc4">removeChild</a> (<a class="el" href="classWt_1_1WObject.html">WObject</a> *child)</td></tr>
<tr class="memdesc:ad1d60618c6ca687226a5f1bbf1be6dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. <br /></td></tr>
<tr class="separator:ad1d60618c6ca687226a5f1bbf1be6dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f32a263b742f42b73a9353eaa3c7ca"><td class="memTemplParams" colspan="2">template&lt;typename Child &gt; </td></tr>
<tr class="memitem:a00f32a263b742f42b73a9353eaa3c7ca"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Child &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a00f32a263b742f42b73a9353eaa3c7ca">removeChild</a> (Child *child)</td></tr>
<tr class="memdesc:a00f32a263b742f42b73a9353eaa3c7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>.  <a href="#a00f32a263b742f42b73a9353eaa3c7ca">More...</a><br /></td></tr>
<tr class="separator:a00f32a263b742f42b73a9353eaa3c7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34b0c9ec343cf467f8b237d3256792"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a9f34b0c9ec343cf467f8b237d3256792">id</a> () const</td></tr>
<tr class="memdesc:a9f34b0c9ec343cf467f8b237d3256792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (unique) identifier for this object.  <a href="#a9f34b0c9ec343cf467f8b237d3256792">More...</a><br /></td></tr>
<tr class="separator:a9f34b0c9ec343cf467f8b237d3256792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875fda02eff6260ab665647f7215e262"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262">setObjectName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a875fda02eff6260ab665647f7215e262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an object name.  <a href="#a875fda02eff6260ab665647f7215e262">More...</a><br /></td></tr>
<tr class="separator:a875fda02eff6260ab665647f7215e262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73aedaccd24488c182912782de70ce2d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a73aedaccd24488c182912782de70ce2d">objectName</a> () const</td></tr>
<tr class="memdesc:a73aedaccd24488c182912782de70ce2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object name.  <a href="#a73aedaccd24488c182912782de70ce2d">More...</a><br /></td></tr>
<tr class="separator:a73aedaccd24488c182912782de70ce2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d8b00edc79b7a60d41d7c088f50436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436">resetLearnedSlots</a> ()</td></tr>
<tr class="memdesc:a92d8b00edc79b7a60d41d7c088f50436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets learned stateless slot implementations.  <a href="#a92d8b00edc79b7a60d41d7c088f50436">More...</a><br /></td></tr>
<tr class="separator:a92d8b00edc79b7a60d41d7c088f50436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698">resetLearnedSlot</a> (void(T::*method)())</td></tr>
<tr class="memdesc:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a learned stateless slot implementation.  <a href="#a5c7dcd5a60c88e5b36f0c8e0f9117698">More...</a><br /></td></tr>
<tr class="separator:a5c7dcd5a60c88e5b36f0c8e0f9117698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="memTemplItemLeft" align="right" valign="top">WStatelessSlot *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless</a> (void(T::*method)())</td></tr>
<tr class="memdesc:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a slot to be stateless and learn client-side behaviour on first invocation.  <a href="#adaa163b9e92933f3b2ff4ec58e2734c6">More...</a><br /></td></tr>
<tr class="separator:adaa163b9e92933f3b2ff4ec58e2734c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf46fd1437f07150a9dd95bd95c266d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bf46fd1437f07150a9dd95bd95c266d"><td class="memTemplItemLeft" align="right" valign="top">WStatelessSlot *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a7bf46fd1437f07150a9dd95bd95c266d">implementStateless</a> (void(T::*method)(), void(T::*undoMethod)())</td></tr>
<tr class="memdesc:a7bf46fd1437f07150a9dd95bd95c266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a slot to be stateless and learn client-side behaviour in advance.  <a href="#a7bf46fd1437f07150a9dd95bd95c266d">More...</a><br /></td></tr>
<tr class="separator:a7bf46fd1437f07150a9dd95bd95c266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dde4ce1e833a9966709daf3c0dedc9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a6dde4ce1e833a9966709daf3c0dedc9f">isNotStateless</a> ()</td></tr>
<tr class="memdesc:a6dde4ce1e833a9966709daf3c0dedc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the current function as not stateless.  <a href="#a6dde4ce1e833a9966709daf3c0dedc9f">More...</a><br /></td></tr>
<tr class="separator:a6dde4ce1e833a9966709daf3c0dedc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214deee5d7324b9afd4ce44534daa782"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a214deee5d7324b9afd4ce44534daa782"><td class="memTemplItemLeft" align="right" valign="top">WStatelessSlot *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#a214deee5d7324b9afd4ce44534daa782">implementJavaScript</a> (void(T::*method)(), const std::string &amp;jsCode)</td></tr>
<tr class="memdesc:a214deee5d7324b9afd4ce44534daa782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a JavaScript implementation for a method.  <a href="#a214deee5d7324b9afd4ce44534daa782">More...</a><br /></td></tr>
<tr class="separator:a214deee5d7324b9afd4ce44534daa782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classWt_1_1Core_1_1observable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classWt_1_1Core_1_1observable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classWt_1_1Core_1_1observable.html">Wt::Core::observable</a></td></tr>
<tr class="memitem:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top"><a id="ac18aee9da79a11ad8492ed5e95ed52e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#ac18aee9da79a11ad8492ed5e95ed52e4">observable</a> () noexcept</td></tr>
<tr class="memdesc:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ac18aee9da79a11ad8492ed5e95ed52e4 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#aaff32cdbd6cd167b3e384f0d7ee7d0b8">~observable</a> ()</td></tr>
<tr class="memdesc:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classWt_1_1Core_1_1observable.html#aaff32cdbd6cd167b3e384f0d7ee7d0b8">More...</a><br /></td></tr>
<tr class="separator:aaff32cdbd6cd167b3e384f0d7ee7d0b8 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename C &gt; </td></tr>
<tr class="memitem:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#a836dedaeb83d6002de00d6ac2a5b0315">bindSafe</a> (void(C::*method)(Args...)) noexcept</td></tr>
<tr class="memdesc:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects a method call against object destruction.  <a href="classWt_1_1Core_1_1observable.html#a836dedaeb83d6002de00d6ac2a5b0315">More...</a><br /></td></tr>
<tr class="separator:a836dedaeb83d6002de00d6ac2a5b0315 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename C &gt; </td></tr>
<tr class="memitem:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#aaae8420328720c8b37c31613dda586ad">bindSafe</a> (void(C::*method)(Args...) const) const noexcept</td></tr>
<tr class="memdesc:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects a const method call against object destruction.  <a href="classWt_1_1Core_1_1observable.html#aaae8420328720c8b37c31613dda586ad">More...</a><br /></td></tr>
<tr class="separator:aaae8420328720c8b37c31613dda586ad inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWt_1_1Core_1_1observable.html#a8f17f1b96a1a3967f4c6c30150c95d58">bindSafe</a> (const Function &amp;function) noexcept</td></tr>
<tr class="memdesc:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protects a function against object destruction.  <a href="classWt_1_1Core_1_1observable.html#a8f17f1b96a1a3967f4c6c30150c95d58">More...</a><br /></td></tr>
<tr class="separator:a8f17f1b96a1a3967f4c6c30150c95d58 inherit pub_methods_classWt_1_1Core_1_1observable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adbed50331d6abf7c19628b3140daa9b4"><td class="memItemLeft" align="right" valign="top">virtual WStatelessSlot *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1WObject.html#adbed50331d6abf7c19628b3140daa9b4">getStateless</a> (<a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a> method)</td></tr>
<tr class="memdesc:adbed50331d6abf7c19628b3140daa9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">On-demand stateless slot implementation.  <a href="#adbed50331d6abf7c19628b3140daa9b4">More...</a><br /></td></tr>
<tr class="separator:adbed50331d6abf7c19628b3140daa9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A base class for objects that participate in the signal/slot system. </p>
<p>The main feature offered by WObject is automated object life-time tracking when involved in signal/slot connections. Connections between signals and slots of WObject instances implement a type-safe event callback system. For example, one can simply connect() the <a class="el" href="classWt_1_1WInteractWidget.html#af6cb297f8593e6884de66d23ea69d49c" title="Event signal emitted when a mouse key was clicked on this widget.">WInteractWidget::clicked()</a> signal of a <a class="el" href="classWt_1_1WPushButton.html" title="A widget that represents a push button.">WPushButton</a> to the <a class="el" href="classWt_1_1WApplication.html#a5231d54ed34982f4366058eb6440c8f7" title="Quits the application.">WApplication::quit()</a> method, to exit the application when the button is clicked:</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Wt::WInteractWidget&gt; sender{<span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html">Wt::WText</a>(<span class="stringliteral">&quot;Quit.&quot;</span>)};</div><div class="line"><a class="code" href="classWt_1_1WApplication.html">Wt::WApplication</a> *app = <a class="code" href="classWt_1_1WApplication.html#a0a866fd44045f2e1685790b1c3c4cb41">Wt::WApplication::instance</a>();</div><div class="line">sender-&gt;clicked().connect(app, &amp;<a class="code" href="classWt_1_1WApplication.html#a5231d54ed34982f4366058eb6440c8f7">Wt::WApplication::quit</a>);</div></div><!-- fragment --><p>Wt's signals may also propagate arguments to slots. For example, the same clicked() signal provides event details in a <a class="el" href="classWt_1_1WMouseEvent.html" title="A class providing details for a mouse event.">WMouseEvent</a> details class, and these details may be received in the slot: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MyClass()</div><div class="line">  {</div><div class="line">    <a class="code" href="classWt_1_1WText.html">Wt::WText</a> *text = addWidget(std::make_unique&lt;Wt::WText&gt;(<span class="stringliteral">&quot;Click here&quot;</span>));</div><div class="line">    text-&gt;<a class="code" href="classWt_1_1WInteractWidget.html#af6cb297f8593e6884de66d23ea69d49c">clicked</a>().connect(<span class="keyword">this</span>, &amp;MyClass::handleClick);</div><div class="line"></div><div class="line">    ...</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> handleClick(<span class="keyword">const</span> <a class="code" href="classWt_1_1WMouseEvent.html">Wt::WMouseEvent</a>&amp; event) {</div><div class="line">    <span class="keywordflow">if</span> (event.<a class="code" href="classWt_1_1WMouseEvent.html#a546499e074ae403057f5acda1da1be0f">modifiers</a>().<a class="code" href="classWt_1_1WFlags.html#a91a1f471ef60b8bc8abf45cdcc68f576">test</a>(<a class="code" href="group__signalslot.html#gga50f91169486bada5931f3adc3a623091a825a3d98017bab11815ad2817201324c">Wt::KeyboardModifier::Shift</a>)) {</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> As the example illustrates, slots are ordinary WObject methods.</p>
<p>In conjunction with <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a>, WObject also facilitates learning of client-side event handling (in JavaScript) through invocation of the slot method. This is only possible when the slot behaviour is stateless, i.e. independent of any application state, and can be specified using the <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> methods.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Signal.html" title="A signal that propagates events to listeners.">Signal</a>, <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a73777218b9a77b674e15a62d14eab734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73777218b9a77b674e15a62d14eab734">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Child &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Child* Wt::WObject::addChild </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Child &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, returning a raw pointer. </p>
<p>This is implemented as:</p>
<div class="fragment"><div class="line">Child *result = child.get();</div><div class="line"><a class="code" href="classWt_1_1WObject.html#a3de0f0baf35f42aa4e77a90d427f2e11">addChild</a>(std::unique_ptr&lt;WObject&gt;(std::move(child)));</div><div class="line"><span class="keywordflow">return</span> result;</div></div><!-- fragment --> 
</div>
</div>
<a id="adbed50331d6abf7c19628b3140daa9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbed50331d6abf7c19628b3140daa9b4">&#9670;&nbsp;</a></span>getStateless()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual WStatelessSlot* Wt::WObject::getStateless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWt_1_1WObject.html#aec904644d278b09d3f7e568fd2efd400">Method</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On-demand stateless slot implementation. </p>
<p>This method returns a stateless slot implementation for the given <code>method</code>. To avoid the cost of declaring methods to be stateless when they are not used, you may reimplement this method to provide a stateless implementation for a method only when the method is involved in a slot connection.</p>
<p>Use <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> to provide a stateless implementation of the given <code>method</code>, or return the base class implementation otherwise. </p>

<p>Reimplemented in <a class="el" href="classWt_1_1WWidget.html#af0055d333414c99aee674e13da95f89b">Wt::WWidget</a>, <a class="el" href="classWt_1_1WWebWidget.html#a603ed3e92421dab3c96dda05afa47513">Wt::WWebWidget</a>, and <a class="el" href="classWt_1_1WAbstractToggleButton.html#adf52bd04a8c10ff6dda2db224e25cb71">Wt::WAbstractToggleButton</a>.</p>

</div>
</div>
<a id="a9f34b0c9ec343cf467f8b237d3256792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f34b0c9ec343cf467f8b237d3256792">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string Wt::WObject::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the (unique) identifier for this object. </p>
<p>For a WWidget, this corresponds to the id of the DOM element that represents the widget. This is not entirely unique, since a <a class="el" href="classWt_1_1WCompositeWidget.html">composite widget</a> shares the same id as its implementation.</p>
<p>By default, the id is auto-generated, unless a custom id is set for a widget using <a class="el" href="classWt_1_1WWidget.html#a93ff9d1ca04e733cd54cd40a06775f7e" title="Sets the CSS Id.">WWidget::setId()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WWidget.html#a83a186d2feacfbfbdb5b54f4cefc6735" title="Returns a JavaScript expression to the corresponding DOM node.">WWidget::jsRef()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1WWebWidget.html#ab438c51f9184d0ed37d01b15f07355d6">Wt::WWebWidget</a>, <a class="el" href="classWt_1_1WTableRow.html#ae0097a7de92acdb677f3b98e0b993f93">Wt::WTableRow</a>, <a class="el" href="classWt_1_1WButtonGroup.html#a2f1b5269d9dae69bdc78aaa8ede36e1b">Wt::WButtonGroup</a>, <a class="el" href="classWt_1_1WTableColumn.html#a84baf2a0d96367fe0d6c1a0ca6e49ce9">Wt::WTableColumn</a>, and <a class="el" href="classWt_1_1WCompositeWidget.html#a6e7fc16162314016e109b771ce476d59">Wt::WCompositeWidget</a>.</p>

</div>
</div>
<a id="a214deee5d7324b9afd4ce44534daa782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214deee5d7324b9afd4ce44534daa782">&#9670;&nbsp;</a></span>implementJavaScript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">WStatelessSlot * Wt::WObject::implementJavaScript </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jsCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a JavaScript implementation for a method. </p>
<p>This method sets the JavaScript implementation for a method. As a result, if JavaScript is available, the JavaScript version will be used on the client side and the visual effect of the C++ implementation will be ignored.</p>
<p>This is very similar to an auto-learned stateless slot, but here the learning is avoided by directly setting the JavaScript implementation.</p>
<p>The <code>jsCode</code> should be one or more valid JavaScript statements.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless(void (T::*method)())</a> </dd></dl>

</div>
</div>
<a id="adaa163b9e92933f3b2ff4ec58e2734c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa163b9e92933f3b2ff4ec58e2734c6">&#9670;&nbsp;</a></span>implementStateless() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">WStatelessSlot * Wt::WObject::implementStateless </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a slot to be stateless and learn client-side behaviour on first invocation. </p>
<p>Indicate that the given slot is stateless, and meets the requirement that the slot's code does not depend on any state of the object, but performs the same visual effect regardless of any state, or at least until <a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a> is called.</p>
<p>When this slot is connected to an <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a> (such as those exposed by <a class="el" href="classWt_1_1WInteractWidget.html" title="An abstract widget that can receive user-interface interaction.">WInteractWidget</a> and <a class="el" href="classWt_1_1WFormWidget.html" title="An abstract widget that corresponds to an HTML form element.">WFormWidget</a>), the Wt library may decide to cache the visual effect of this slot in JavaScript code at client-side: this effect will be learned automatically at the first invocation. This has no consequences for the normal event handling, since the slot implementation is still executed in response to any event notification. Therefore, it is merely an optimization of the latency for the visual effect, but it does not change the behaviour of the application.</p>
<p>When for some reason the visual effect does change, one may use <a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a> or <a class="el" href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436" title="Resets learned stateless slot implementations.">resetLearnedSlots()</a> to flush the existing cached visual effect, forcing the library to relearn it.</p>
<p>It is crucial that this function be applied first to a slot that is intended to be stateless before any EventSignal connects to that slot. Otherwise, the connecting EventSignal cannot find the stateless slot implementation for the intended slot, and the statement will have no effect for that connection.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a>, <a class="el" href="classWt_1_1EventSignal.html" title="A signal that conveys user-interface events.">EventSignal</a> </dd></dl>

</div>
</div>
<a id="a7bf46fd1437f07150a9dd95bd95c266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf46fd1437f07150a9dd95bd95c266d">&#9670;&nbsp;</a></span>implementStateless() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">WStatelessSlot * Wt::WObject::implementStateless </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>undoMethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a slot to be stateless and learn client-side behaviour in advance. </p>
<p>This method has the same effect as <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless(void (T::*method)())</a>, but learns the visual effect of the slot before the first invocation of the event.</p>
<p>To learn the visual effect, the library will simulate the event and record the visual effect. To restore the application state, it will call the undoMethod which must restore the effect of method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6">implementStateless(void (T::*method)())</a> </dd></dl>

</div>
</div>
<a id="a6dde4ce1e833a9966709daf3c0dedc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dde4ce1e833a9966709daf3c0dedc9f">&#9670;&nbsp;</a></span>isNotStateless()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WObject::isNotStateless </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the current function as not stateless. </p>
<p>This may be useful if your current function is manipulating the UI in a way that is not stateless (i.e. does depend on some state), but which happens to be called from within a function that is marked stateless (such as <a class="el" href="classWt_1_1WWidget.html#a66bdda41220267a8c7ff9865996e2675" title="Hides or shows the widget.">WWidget::setHidden()</a>). This will reject stateless slot pre-learning in this case, reverting to plain server-side dynamic UI updates. </p>

</div>
</div>
<a id="a73aedaccd24488c182912782de70ce2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73aedaccd24488c182912782de70ce2d">&#9670;&nbsp;</a></span>objectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Wt::WObject::objectName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object name. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#a875fda02eff6260ab665647f7215e262" title="Sets an object name.">setObjectName()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classWt_1_1WCompositeWidget.html#a379aaf81ec17f4f17befd1979df17ab1">Wt::WCompositeWidget</a>.</p>

</div>
</div>
<a id="a00f32a263b742f42b73a9353eaa3c7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f32a263b742f42b73a9353eaa3c7ca">&#9670;&nbsp;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Child &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Child&gt; Wt::WObject::removeChild </td>
          <td>(</td>
          <td class="paramtype">Child *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a child <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>, so its lifetime is no longer determined by this <a class="el" href="classWt_1_1WObject.html" title="A base class for objects that participate in the signal/slot system.">WObject</a>. </p>
<p>This is an overload that automatically casts the returned value to a unique_ptr&lt;Child&gt; for convenience</p>
<p>This is implemented as: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> std::unique_ptr&lt;Child&gt;(static_cast&lt;Child*&gt;(<a class="code" href="classWt_1_1WObject.html#ad1d60618c6ca687226a5f1bbf1be6dc4">removeChild</a>(static_cast&lt;WObject*&gt;(child)).release()));</div></div><!-- fragment --> 
</div>
</div>
<a id="a5c7dcd5a60c88e5b36f0c8e0f9117698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7dcd5a60c88e5b36f0c8e0f9117698">&#9670;&nbsp;</a></span>resetLearnedSlot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WObject::resetLearnedSlot </td>
          <td>(</td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a learned stateless slot implementation. </p>
<p>Clears the stateless implementation for the given slot that was declared to be implemented with a stateless implementation.</p>
<p>When something has changed that breaks the contract of a stateless slot to always have the same effect, you may call this method to force the application to discard the current implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> </dd></dl>

</div>
</div>
<a id="a92d8b00edc79b7a60d41d7c088f50436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d8b00edc79b7a60d41d7c088f50436">&#9670;&nbsp;</a></span>resetLearnedSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Wt::WObject::resetLearnedSlots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets learned stateless slot implementations. </p>
<p>Clears the stateless implementation for all slots declared to be implemented with a stateless implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1WObject.html#a5c7dcd5a60c88e5b36f0c8e0f9117698" title="Resets a learned stateless slot implementation.">resetLearnedSlot()</a>, <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">implementStateless()</a> </dd></dl>

</div>
</div>
<a id="a875fda02eff6260ab665647f7215e262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875fda02eff6260ab665647f7215e262">&#9670;&nbsp;</a></span>setObjectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Wt::WObject::setObjectName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an object name. </p>
<p>The object name can be used to easily identify a type of object in the DOM, and does not need to be unique. It will usually reflect the widget type or role.</p>
<p>The object name is present in the DOM in the 'data-object-name' attribute.</p>
<p>The default object name is empty (no object name). </p>

<p>Reimplemented in <a class="el" href="classWt_1_1WWebWidget.html#a8a90ac0a5b963994ee0e5ff35213b276">Wt::WWebWidget</a>, and <a class="el" href="classWt_1_1WCompositeWidget.html#a0f46cc7bc8e0aa368837dcc138303c76">Wt::WCompositeWidget</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><address style="text-align: right; margin: 3px"><small>
Generated on Wed Apr 22 2020 for <a href="http://www.webtoolkit.eu/wt">the
C++ Web Toolkit (Wt)</a> by&nbsp;<a
href="http://www.doxygen.org/index.html"><img src="doxygen.png"
alt="doxygen" border="0" style="vertical-align: middle; display:
inline-block; height: 2em"></a> 1.8.15</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wt: Wt::Dbo::ptr&lt; C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wt
   &#160;<span id="projectnumber">4.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWt.html">Wt</a></li><li class="navelem"><a class="el" href="namespaceWt_1_1Dbo.html">Dbo</a></li><li class="navelem"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classWt_1_1Dbo_1_1ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wt::Dbo::ptr&lt; C &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dbo.html">Database Objects (Wt::Dbo)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A smart pointer for a database object.  
 <a href="classWt_1_1Dbo_1_1ptr.html#details">More...</a></p>

<p><code>#include &lt;Wt/Dbo/ptr.h&gt;</code></p>

<p>Inherits Wt::Dbo::ptr_base.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb1a7ca897aceba6cef6c0ba156ffbaf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#acb1a7ca897aceba6cef6c0ba156ffbaf">ptr</a> (std::unique_ptr&lt; C &gt; obj)</td></tr>
<tr class="memdesc:acb1a7ca897aceba6cef6c0ba156ffbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new pointer.  <a href="#acb1a7ca897aceba6cef6c0ba156ffbaf">More...</a><br /></td></tr>
<tr class="separator:acb1a7ca897aceba6cef6c0ba156ffbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cdf1ba27d9b31cb03c37d16ded0776"><td class="memItemLeft" align="right" valign="top"><a id="ae8cdf1ba27d9b31cb03c37d16ded0776"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#ae8cdf1ba27d9b31cb03c37d16ded0776">ptr</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other)</td></tr>
<tr class="memdesc:ae8cdf1ba27d9b31cb03c37d16ded0776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:ae8cdf1ba27d9b31cb03c37d16ded0776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2187f5ef7d8990a0b8564423a623def"><td class="memItemLeft" align="right" valign="top"><a id="af2187f5ef7d8990a0b8564423a623def"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af2187f5ef7d8990a0b8564423a623def">ptr</a> (<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:af2187f5ef7d8990a0b8564423a623def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:af2187f5ef7d8990a0b8564423a623def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba24bdad5f3536eabe1a378d3d2bdec"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a8ba24bdad5f3536eabe1a378d3d2bdec">~ptr</a> ()</td></tr>
<tr class="memdesc:a8ba24bdad5f3536eabe1a378d3d2bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a8ba24bdad5f3536eabe1a378d3d2bdec">More...</a><br /></td></tr>
<tr class="separator:a8ba24bdad5f3536eabe1a378d3d2bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7cc35a218d2f8ad616d89a12c85a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a4d7cc35a218d2f8ad616d89a12c85a77">reset</a> (std::unique_ptr&lt; C &gt; obj=nullptr)</td></tr>
<tr class="memdesc:a4d7cc35a218d2f8ad616d89a12c85a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the pointer.  <a href="#a4d7cc35a218d2f8ad616d89a12c85a77">More...</a><br /></td></tr>
<tr class="separator:a4d7cc35a218d2f8ad616d89a12c85a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ea4ded2103a4ec31306549cbbf74f5"><td class="memItemLeft" align="right" valign="top"><a id="af8ea4ded2103a4ec31306549cbbf74f5"></a>
<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af8ea4ded2103a4ec31306549cbbf74f5">operator=</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other)</td></tr>
<tr class="memdesc:af8ea4ded2103a4ec31306549cbbf74f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:af8ea4ded2103a4ec31306549cbbf74f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1dcd0318ad2def6a63717a23852571"><td class="memItemLeft" align="right" valign="top"><a id="aeb1dcd0318ad2def6a63717a23852571"></a>
<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#aeb1dcd0318ad2def6a63717a23852571">operator=</a> (<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aeb1dcd0318ad2def6a63717a23852571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:aeb1dcd0318ad2def6a63717a23852571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41a6f16026dfe3f5834ffd2d94876c8"><td class="memItemLeft" align="right" valign="top">const C *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af41a6f16026dfe3f5834ffd2d94876c8">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:af41a6f16026dfe3f5834ffd2d94876c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator.  <a href="#af41a6f16026dfe3f5834ffd2d94876c8">More...</a><br /></td></tr>
<tr class="separator:af41a6f16026dfe3f5834ffd2d94876c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0f2713f997bf4724a5a6c3b65eb34f"><td class="memItemLeft" align="right" valign="top">const C *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a5c0f2713f997bf4724a5a6c3b65eb34f">get</a> () const</td></tr>
<tr class="memdesc:a5c0f2713f997bf4724a5a6c3b65eb34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer.  <a href="#a5c0f2713f997bf4724a5a6c3b65eb34f">More...</a><br /></td></tr>
<tr class="separator:a5c0f2713f997bf4724a5a6c3b65eb34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2ad3a40b74bbcc9aaf66a51e9ac0f"><td class="memItemLeft" align="right" valign="top">const C &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a7ea2ad3a40b74bbcc9aaf66a51e9ac0f">operator *</a> () const</td></tr>
<tr class="memdesc:a7ea2ad3a40b74bbcc9aaf66a51e9ac0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator.  <a href="#a7ea2ad3a40b74bbcc9aaf66a51e9ac0f">More...</a><br /></td></tr>
<tr class="separator:a7ea2ad3a40b74bbcc9aaf66a51e9ac0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2339083c75cfa385462d761a193d6f4"><td class="memItemLeft" align="right" valign="top">C *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa2339083c75cfa385462d761a193d6f4">modify</a> () const</td></tr>
<tr class="memdesc:aa2339083c75cfa385462d761a193d6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference operator, for writing.  <a href="#aa2339083c75cfa385462d761a193d6f4">More...</a><br /></td></tr>
<tr class="separator:aa2339083c75cfa385462d761a193d6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365da121b7dd612909ad9573fb2b3722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a365da121b7dd612909ad9573fb2b3722">operator==</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other) const</td></tr>
<tr class="memdesc:a365da121b7dd612909ad9573fb2b3722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#a365da121b7dd612909ad9573fb2b3722">More...</a><br /></td></tr>
<tr class="separator:a365da121b7dd612909ad9573fb2b3722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d706c7c774770fdf50192631b8db4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#ae4d706c7c774770fdf50192631b8db4b">operator==</a> (const <a class="el" href="classWt_1_1Dbo_1_1weak__ptr.html">weak_ptr</a>&lt; C &gt; &amp;other) const</td></tr>
<tr class="memdesc:ae4d706c7c774770fdf50192631b8db4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#ae4d706c7c774770fdf50192631b8db4b">More...</a><br /></td></tr>
<tr class="separator:ae4d706c7c774770fdf50192631b8db4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90c745b43e983bf7a272f8b0ff7660b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af90c745b43e983bf7a272f8b0ff7660b">operator!=</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other) const</td></tr>
<tr class="memdesc:af90c745b43e983bf7a272f8b0ff7660b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#af90c745b43e983bf7a272f8b0ff7660b">More...</a><br /></td></tr>
<tr class="separator:af90c745b43e983bf7a272f8b0ff7660b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e819d1768f9d8c09becbac63bba2057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a6e819d1768f9d8c09becbac63bba2057">operator!=</a> (const <a class="el" href="classWt_1_1Dbo_1_1weak__ptr.html">weak_ptr</a>&lt; C &gt; &amp;other) const</td></tr>
<tr class="memdesc:a6e819d1768f9d8c09becbac63bba2057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#a6e819d1768f9d8c09becbac63bba2057">More...</a><br /></td></tr>
<tr class="separator:a6e819d1768f9d8c09becbac63bba2057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe385938519566aa478ce1be22666645"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#afe385938519566aa478ce1be22666645">operator&lt;</a> (const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;other) const</td></tr>
<tr class="memdesc:afe385938519566aa478ce1be22666645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="#afe385938519566aa478ce1be22666645">More...</a><br /></td></tr>
<tr class="separator:afe385938519566aa478ce1be22666645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd6d14d3bdf0f98b4bce58d647c1765"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#adbd6d14d3bdf0f98b4bce58d647c1765">operator bool</a> () const</td></tr>
<tr class="memdesc:adbd6d14d3bdf0f98b4bce58d647c1765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for null.  <a href="#adbd6d14d3bdf0f98b4bce58d647c1765">More...</a><br /></td></tr>
<tr class="separator:adbd6d14d3bdf0f98b4bce58d647c1765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89bd2945ce8aeaf0109391e84a0adf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#ab89bd2945ce8aeaf0109391e84a0adf3">flush</a> () const</td></tr>
<tr class="memdesc:ab89bd2945ce8aeaf0109391e84a0adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the object.  <a href="#ab89bd2945ce8aeaf0109391e84a0adf3">More...</a><br /></td></tr>
<tr class="separator:ab89bd2945ce8aeaf0109391e84a0adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b26afebd56abc42005ef9f954d8fee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af4b26afebd56abc42005ef9f954d8fee">remove</a> ()</td></tr>
<tr class="memdesc:af4b26afebd56abc42005ef9f954d8fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an object from the database.  <a href="#af4b26afebd56abc42005ef9f954d8fee">More...</a><br /></td></tr>
<tr class="separator:af4b26afebd56abc42005ef9f954d8fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1db71ef910748437d69bf11a04eb6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#abb1db71ef910748437d69bf11a04eb6e">reread</a> ()</td></tr>
<tr class="memdesc:abb1db71ef910748437d69bf11a04eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rereads the database version.  <a href="#abb1db71ef910748437d69bf11a04eb6e">More...</a><br /></td></tr>
<tr class="separator:abb1db71ef910748437d69bf11a04eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7330a5220e3e926b5c084444116499a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a7330a5220e3e926b5c084444116499a4">purge</a> ()</td></tr>
<tr class="memdesc:a7330a5220e3e926b5c084444116499a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purges an object from memory.  <a href="#a7330a5220e3e926b5c084444116499a4">More...</a><br /></td></tr>
<tr class="separator:a7330a5220e3e926b5c084444116499a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f13eaa3b68e0e26277ab8999504e326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structWt_1_1Dbo_1_1dbo__traits.html">dbo_traits</a>&lt; C &gt;::IdType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a7f13eaa3b68e0e26277ab8999504e326">id</a> () const</td></tr>
<tr class="memdesc:a7f13eaa3b68e0e26277ab8999504e326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object id.  <a href="#a7f13eaa3b68e0e26277ab8999504e326">More...</a><br /></td></tr>
<tr class="separator:a7f13eaa3b68e0e26277ab8999504e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3144ce3a7c4caddb4746a097d82aa841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a3144ce3a7c4caddb4746a097d82aa841">version</a> () const</td></tr>
<tr class="memdesc:a3144ce3a7c4caddb4746a097d82aa841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object version.  <a href="#a3144ce3a7c4caddb4746a097d82aa841">More...</a><br /></td></tr>
<tr class="separator:a3144ce3a7c4caddb4746a097d82aa841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30160e3a92c9203dba71386b6fec65e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a30160e3a92c9203dba71386b6fec65e9">isTransient</a> () const</td></tr>
<tr class="memdesc:a30160e3a92c9203dba71386b6fec65e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object is transient.  <a href="#a30160e3a92c9203dba71386b6fec65e9">More...</a><br /></td></tr>
<tr class="separator:a30160e3a92c9203dba71386b6fec65e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16df72641a0a7d96b73cadcb5edbd94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa16df72641a0a7d96b73cadcb5edbd94">isDirty</a> () const</td></tr>
<tr class="memdesc:aa16df72641a0a7d96b73cadcb5edbd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the object is dirty.  <a href="#aa16df72641a0a7d96b73cadcb5edbd94">More...</a><br /></td></tr>
<tr class="separator:aa16df72641a0a7d96b73cadcb5edbd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ef98bc17f1eba0d11876f347d14486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWt_1_1Dbo_1_1Session.html">Session</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a91ef98bc17f1eba0d11876f347d14486">session</a> () const</td></tr>
<tr class="memdesc:a91ef98bc17f1eba0d11876f347d14486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the session with which this pointer is associated.  <a href="#a91ef98bc17f1eba0d11876f347d14486">More...</a><br /></td></tr>
<tr class="separator:a91ef98bc17f1eba0d11876f347d14486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class C&gt;<br />
class Wt::Dbo::ptr&lt; C &gt;</h3>

<p>A smart pointer for a database object. </p>
<p>This smart pointer class implements a reference counted shared pointer for database objects, which also keeps tracking of synchronization between the in-memory copy and the database copy. You should always use this pointer class to reference a database object.</p>
<p>Unlike typical C++ data structures, classes mapped to database tables do not have clear ownership relationships. Therefore, the conventional ownership-based memory allocation/deallocation does not work naturally for database classes.</p>
<p>A pointer may point to a <em>transient</em> object or a <em>persisted</em> object. A persisted object has a corresponding copy in the database while a transient object is only present in memory. To persist a new object, use <a class="el" href="classWt_1_1Dbo_1_1Session.html#abfbd5bea3a6b964e833c893434e38c8f" title="Persists a transient object.">Session::add()</a>. To make a persisted object transient, use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#af4b26afebd56abc42005ef9f954d8fee" title="Removes an object from the database.">remove()</a>.</p>
<p>Unlike a typical smart pointer, this pointer only allows read access to the underlying object by default. To modify the object, you should explicitly use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa2339083c75cfa385462d761a193d6f4" title="Dereference operator, for writing.">modify()</a>. This is used to mark the underyling object as <em>dirty</em> to add it to the queue of objects to be synchronized with the database.</p>
<p>The pointer class provides a number of methods to deal with the persistence state of the object:</p><ul>
<li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a7f13eaa3b68e0e26277ab8999504e326" title="Returns the object id.">id()</a>: returns the database id</li>
<li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#ab89bd2945ce8aeaf0109391e84a0adf3" title="Flushes the object.">flush()</a>: forces the object to be synchronized to the database</li>
<li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#af4b26afebd56abc42005ef9f954d8fee" title="Removes an object from the database.">remove()</a>: deletes the object in the underlying database</li>
<li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#abb1db71ef910748437d69bf11a04eb6e" title="Rereads the database version.">reread()</a>: rereads the database copy of the object</li>
<li><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a7330a5220e3e926b5c084444116499a4" title="Purges an object from memory.">purge()</a>: purges the transient version of a non-dirty object.</li>
</ul>
<p>Wt::Dbo::ptr&lt;const C&gt; can be used when retrieving query results. There are overloads for the copy constructor, copy assignment, and comparison operators to make this work as expected. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb1a7ca897aceba6cef6c0ba156ffbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1a7ca897aceba6cef6c0ba156ffbaf">&#9670;&nbsp;</a></span>ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; C &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new pointer. </p>
<p>When <code>obj</code> is not <code>nullptr</code>, the pointer points to the new unpersisted object. Use <a class="el" href="classWt_1_1Dbo_1_1Session.html#abfbd5bea3a6b964e833c893434e38c8f" title="Persists a transient object.">Session::add()</a> to persist the newly created object. </p>

</div>
</div>
<a id="a8ba24bdad5f3536eabe1a378d3d2bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba24bdad5f3536eabe1a378d3d2bdec">&#9670;&nbsp;</a></span>~ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::~<a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This method will delete the transient copy of the database object if it is not referenced by any other pointer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab89bd2945ce8aeaf0109391e84a0adf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89bd2945ce8aeaf0109391e84a0adf3">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the object. </p>
<p>If dirty, the object is synchronized to the database. This will automatically also flush objects that are referenced by this object if needed. The object is not actually committed to the database before the active transaction has been committed.</p>
<p>Since this may persist object to the database, you should have an active transaction. </p>

</div>
</div>
<a id="a5c0f2713f997bf4724a5a6c3b65eb34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0f2713f997bf4724a5a6c3b65eb34f">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const C * <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the pointer. </p>
<p>Note that returns a const pointer. Use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa2339083c75cfa385462d761a193d6f4" title="Dereference operator, for writing.">modify()</a> to get a non-const pointer.</p>
<p>Since this may lazy-load the underlying database object, you should have an active transaction.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa2339083c75cfa385462d761a193d6f4" title="Dereference operator, for writing.">modify()</a> </dd></dl>

</div>
</div>
<a id="a7f13eaa3b68e0e26277ab8999504e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f13eaa3b68e0e26277ab8999504e326">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWt_1_1Dbo_1_1dbo__traits.html">dbo_traits</a>&lt; C &gt;::IdType <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the object id. </p>
<p>This returns <a class="el" href="structWt_1_1Dbo_1_1dbo__traits.html#aae2a13a4ca038f5bad337fbc2d70d37c" title="Returns the sentinel value for a null id.">dbo_traits&lt;C&gt;::invalidId()</a> for a transient object. </p>

</div>
</div>
<a id="aa16df72641a0a7d96b73cadcb5edbd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16df72641a0a7d96b73cadcb5edbd94">&#9670;&nbsp;</a></span>isDirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::isDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the object is dirty. </p>
<p>A dirty object will be flushed whenever a query is made or the current transaction ends. </p>

</div>
</div>
<a id="a30160e3a92c9203dba71386b6fec65e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30160e3a92c9203dba71386b6fec65e9">&#9670;&nbsp;</a></span>isTransient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::isTransient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the object is transient. </p>
<p>This returns true for a transient object. </p>

</div>
</div>
<a id="aa2339083c75cfa385462d761a193d6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2339083c75cfa385462d761a193d6f4">&#9670;&nbsp;</a></span>modify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt;::mutator <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::modify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference operator, for writing. </p>
<p>Returns the underlying object (or, rather, a proxy for it) with the intention to modify it. The proxy object will mark the object as dirty from its destructor. An involved modification should therefore preferably be implemented as a separate method or function to make sure that the object is marked as dirty after the whole modification: </p><div class="fragment"><div class="line">ptr&lt;A&gt; a = ...;</div><div class="line">a.modify()-&gt;doSomething();</div></div><!-- fragment --><p>Since this may lazy-load the underlying database object, you should have an active transaction.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classWt_1_1Dbo_1_1ptr.html#a5c0f2713f997bf4724a5a6c3b65eb34f" title="Returns the pointer.">get()</a> </dd></dl>

</div>
</div>
<a id="a7ea2ad3a40b74bbcc9aaf66a51e9ac0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea2ad3a40b74bbcc9aaf66a51e9ac0f">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const C &amp; <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference operator. </p>
<p>Note that this operator returns a const copy of the referenced object. Use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa2339083c75cfa385462d761a193d6f4" title="Dereference operator, for writing.">modify()</a> to get a non-const reference.</p>
<p>Since this may lazy-load the underlying database object, you should have an active transaction. </p>

</div>
</div>
<a id="adbd6d14d3bdf0f98b4bce58d647c1765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd6d14d3bdf0f98b4bce58d647c1765">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for null. </p>
<p>Returns true if the pointer is pointing to a non-null object. </p>

</div>
</div>
<a id="af90c745b43e983bf7a272f8b0ff7660b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90c745b43e983bf7a272f8b0ff7660b">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Two pointers are equal if and only if they reference the same database object. </p>

</div>
</div>
<a id="a6e819d1768f9d8c09becbac63bba2057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e819d1768f9d8c09becbac63bba2057">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1weak__ptr.html">weak_ptr</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Two pointers are equal if and only if they reference the same database object.</p>
<p>Since this needs to query the value, you should have an active transaction. </p>

</div>
</div>
<a id="af41a6f16026dfe3f5834ffd2d94876c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41a6f16026dfe3f5834ffd2d94876c8">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const C * <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference operator. </p>
<p>Note that this operator returns a const copy of the referenced object. Use <a class="el" href="classWt_1_1Dbo_1_1ptr.html#aa2339083c75cfa385462d761a193d6f4" title="Dereference operator, for writing.">modify()</a> to get a non-const reference.</p>
<p>Since this may lazy-load the underlying database object, you should have an active transaction. </p>

</div>
</div>
<a id="afe385938519566aa478ce1be22666645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe385938519566aa478ce1be22666645">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>This operator is implemented to be able to store pointers in std::set or std::map containers. </p>

</div>
</div>
<a id="a365da121b7dd612909ad9573fb2b3722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365da121b7dd612909ad9573fb2b3722">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1ptr.html">ptr</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Two pointers are equal if and only if they reference the same database object. </p>

</div>
</div>
<a id="ae4d706c7c774770fdf50192631b8db4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d706c7c774770fdf50192631b8db4b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWt_1_1Dbo_1_1weak__ptr.html">weak_ptr</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>Two pointers are equal if and only if they reference the same database object.</p>
<p>Since this needs to query the value, you should have an active transaction. </p>

</div>
</div>
<a id="a7330a5220e3e926b5c084444116499a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7330a5220e3e926b5c084444116499a4">&#9670;&nbsp;</a></span>purge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::purge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Purges an object from memory. </p>
<p>When the object is not dirty, the memory copy of the object is deleted, and the object will be reread from the database on the next access.</p>
<p>Purging an object can be useful to conserve memory, but you should never purge an object while the user is editing if you wish to rely on the optimistick locking for detecting concurrent modifications. </p>

</div>
</div>
<a id="af4b26afebd56abc42005ef9f954d8fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b26afebd56abc42005ef9f954d8fee">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an object from the database. </p>
<p>The object is removed from the database, and becomes transient again.</p>
<p>Note that the object is not deleted in memory: you can still continue to read and modify the object, but there will no longer be a database copy of the object, and the object will effectively be treated as a new object (which may be re-added to the database at a later point).</p>
<p>This is the opposite operation of <a class="el" href="classWt_1_1Dbo_1_1Session.html#abfbd5bea3a6b964e833c893434e38c8f" title="Persists a transient object.">Session::add()</a>. </p>

</div>
</div>
<a id="abb1db71ef910748437d69bf11a04eb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1db71ef910748437d69bf11a04eb6e">&#9670;&nbsp;</a></span>reread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::reread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rereads the database version. </p>
<p>Rereads a persisted object from the database, discarding any possible changes and updating to the latest database version.</p>
<p>This does not actually load the database version, since loading is lazy. </p>

</div>
</div>
<a id="a4d7cc35a218d2f8ad616d89a12c85a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7cc35a218d2f8ad616d89a12c85a77">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; C &gt;&#160;</td>
          <td class="paramname"><em>obj</em> = <code>nullptr&lt;&#160;C&#160;&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the pointer. </p>
<p>This is equivalent to: </p><div class="fragment"><div class="line">p = ptr&lt;C&gt;(std::move(obj));</div></div><!-- fragment --> 
</div>
</div>
<a id="a91ef98bc17f1eba0d11876f347d14486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ef98bc17f1eba0d11876f347d14486">&#9670;&nbsp;</a></span>session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWt_1_1Dbo_1_1Session.html">Session</a> * <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::session </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the session with which this pointer is associated. </p>
<p>This may return <code>nullptr</code> if the pointer is null or not added to a session. </p>

</div>
</div>
<a id="a3144ce3a7c4caddb4746a097d82aa841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3144ce3a7c4caddb4746a097d82aa841">&#9670;&nbsp;</a></span>version()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWt_1_1Dbo_1_1ptr.html">Wt::Dbo::ptr</a>&lt; C &gt;::version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the object version. </p>
<p>This returns -1 for a transient object or when versioning is not enabled. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><address style="text-align: right; margin: 3px"><small>
Generated on Wed Apr 22 2020 for <a href="http://www.webtoolkit.eu/wt">the
C++ Web Toolkit (Wt)</a> by&nbsp;<a
href="http://www.doxygen.org/index.html"><img src="doxygen.png"
alt="doxygen" border="0" style="vertical-align: middle; display:
inline-block; height: 2em"></a> 1.8.15</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wt: Treelist example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wt
   &#160;<span id="projectnumber">4.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Treelist example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we will step through the code of the <a href="https://webtoolkit.eu/wt/examples/treelist/demotreelist.wt">Tree List example</a>. The source code of the entire example is available as leaves of the tree. Note that Wt offers a Tree List widget as part of the library (see <a class="el" href="classWt_1_1WTreeNode.html" title="A single node in a tree.">WTreeNode</a>), of which this example is a stripped down version.</p>
<p>The example in particular demonstrates the use of stateless slot learning to simultaneously implement client-side and server-side event handling in C++.</p>
<p>The tree is constructed as a hierarchy of tree nodes. A single tree node is implemented in the class TreeNode. TreeNode uses the helper class IconPair for rendering icons that have a state (such as the expand/collapse icons). We start with a walk-over of this class.</p>
<h1><a class="anchor" id="stateicon_sec"></a>
IconPair: a pair of icons that reflects state.</h1>
<p>For the implementation of the tree list expand/collapse icons, as well as the label icons (such as the folder icon), we use the IconPair class. It takes a pair of icons and shows only one at a time. Passing clickIsSwitch = true to the constructor will make the icon react to click events to switch the current icon.</p>
<p>This is the class definition of IconPair:</p>
 </p><div class="fragment"><div class="line">/*! \brief An icon pair (identical to WIconPair)</div><div class="line"> *</div><div class="line"> * This widget manages two images, only one of which is shown at a single</div><div class="line"> * time.</div><div class="line"> *</div><div class="line"> * The widget may also react to click events, by changing state.</div><div class="line"> *</div><div class="line"> * This widget is part of the %Wt treelist example, where it is used</div><div class="line"> * to represent the expand/collapse icons, and the corresponding</div><div class="line"> * map open/close icon.</div><div class="line"> *</div><div class="line"> * \sa TreeNode</div><div class="line"> */</div><div class="line">class IconPair : public WCompositeWidget</div><div class="line">{</div><div class="line">public:</div><div class="line">  /*! \brief Construct a two-state icon widget.</div><div class="line">   *</div><div class="line">   * The constructor takes the URI of the two icons. When clickIsSwitch</div><div class="line">   * is set true, clicking on the icon will switch state.</div><div class="line">   */</div><div class="line">  IconPair(const std::string icon1URI, const std::string icon2URI,</div><div class="line">           bool clickIsSwitch = true);</div><div class="line"></div><div class="line">  /*! \brief Set which icon should be visible.</div><div class="line">   *</div><div class="line">   * The first icon has number 0, and the second icon has number 1.</div><div class="line">   *</div><div class="line">   * \sa state()</div><div class="line">   */</div><div class="line">  void setState(int num);</div><div class="line"></div><div class="line">  /*! \brief Get the current state.</div><div class="line">   *</div><div class="line">   * \sa setState()</div><div class="line">   */</div><div class="line">  int state() const;</div><div class="line"></div><div class="line">  /*! \brief Get the first icon image</div><div class="line">   */</div><div class="line">  WImage *icon1() const { return icon1_; }</div><div class="line">  </div><div class="line">  /*! \brief Get the second icon image</div><div class="line">   */</div><div class="line">  WImage *icon2() const { return icon2_; }</div><div class="line"></div><div class="line">  /*! \brief Set state to 0 (show icon 1).</div><div class="line">   */</div><div class="line">  void showIcon1();</div><div class="line"></div><div class="line">  /*! \brief Set state to 1 (show icon 2).</div><div class="line">   */ </div><div class="line">  void showIcon2();</div><div class="line"></div><div class="line">private:</div><div class="line">  WContainerWidget *impl_;</div><div class="line"></div><div class="line">  //! First icon.</div><div class="line">  WImage *icon1_;</div><div class="line"></div><div class="line">  //! Second icon.</div><div class="line">  WImage *icon2_;</div><div class="line"></div><div class="line">public:</div><div class="line">  /*! \brief Signal emitted when clicked while in state 0 (icon 1 is</div><div class="line">   *         shown).</div><div class="line">   */</div><div class="line">  EventSignal&lt;WMouseEvent&gt; *icon1Clicked;</div><div class="line"></div><div class="line">  /*! \brief Signal emitted when clicked while in state 1 (icon 2 is</div><div class="line">   *         shown).</div><div class="line">   */</div><div class="line">  EventSignal&lt;WMouseEvent&gt; *icon2Clicked;</div><div class="line"></div><div class="line">private:</div><div class="line">  //! Undo state for prelearning stateless showIcon1() and showIcon2() slots</div><div class="line">  int previousState_;</div><div class="line"></div><div class="line">  //! Undo function for prelearning showIcon1()</div><div class="line">  void undoShowIcon1();</div><div class="line"></div><div class="line">  //! Undo function for prelearning showIcon2()</div><div class="line">  void undoShowIcon2();</div><div class="line">};</div></div><!-- fragment --><p>IconPair is a composite widget, implemented as a <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a> which contains two <a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> objects. The class defines two slots: IconPair::showIcon1() and IconPair::showIcon2(), which show the respective icon, while hiding the other icon.</p>
<p>Although Wt is a C++ (server-side) library, it can also generate client-side JavaScript code for instant visual response. This example will use this capability to implement all of the tree navigation at the client-side for those clients that support JavaScript &ndash; as if it were implemented as a JavaScript library. But since everything is still plain C++ code, it works regardless of what technology is available or lacking at the client side. Think of a stateless slot implementation as creating a forked implementation, with JavaScript in the client for visual response &ndash; when JavaScript is available, and C++ at the server. When no JavaScript is available, everything happens at the server.</p>
<p>The key concept behind Wt's capability to implement things at the client-side is stateless slot implementations. A stateless slot is, besides a normal C++ function that may be connected to a signal, a C++ function that promises to always have the same behaviour (until it is reset, as we will see later).</p>
<p>This applies to the two functions showIcon1() and showIcon2(), as they simply set the corresponding icon, irrespective of any application state. The library offers two methods for stateless slot implementations: AutoLearned and PreLearned. An AutoLearned stateless slot will only "become client-side" after the first invocation. Applied to our tree widget, this would mean that the first click on any icon would require a round-trip to the server the first time only. An AutoLearned stateless slot simply requires an indication that the particular slot confirms to the contract of being stateless. A PreLearned stateless slot, on the other hand, is "client-side" from the first invocation. To implement a PreLearned stateless however, we need to do some extra work by providing methods that exactly undo the effect of the slot. We provide here two such undo methods: undoShowIcon1() and undoShowIcon2().</p>
<p>Enough talk! Let's look at the implementation, starting with the constructor.</p>
 </p><div class="fragment"><div class="line">IconPair::IconPair(const std::string icon1URI, const std::string icon2URI,</div><div class="line">                   bool clickIsSwitch)</div><div class="line">  : WCompositeWidget(),</div><div class="line">    impl_(nullptr),</div><div class="line">    icon1_(nullptr),</div><div class="line">    icon2_(nullptr),</div><div class="line">    icon1Clicked(nullptr),</div><div class="line">    icon2Clicked(nullptr)</div><div class="line">{</div><div class="line">  auto impl = cpp14::make_unique&lt;WContainerWidget&gt;();</div><div class="line">  impl_ = impl.get();</div><div class="line">  icon1_ = impl_-&gt;addWidget(cpp14::make_unique&lt;WImage&gt;(icon1URI));</div><div class="line">  icon2_ = impl_-&gt;addWidget(cpp14::make_unique&lt;WImage&gt;(icon2URI));</div><div class="line">  icon1Clicked = &amp;icon1_-&gt;clicked();</div><div class="line">  icon2Clicked = &amp;icon2_-&gt;clicked();</div></div><!-- fragment --><p>IconPair inherits from <a class="el" href="classWt_1_1WCompositeWidget.html" title="A widget that hides the implementation of composite widgets.">WCompositeWidget</a>. A composite widget is a widget which is composed from other widgets, in a way not exposed in its API. In this way, you may later change the implementation without any problem.</p>
<p>Notice how we constructed three widgets that are used in the implementation: two images (icon1_ and icon2_), and a container (impl_) to hold them. The images are added to the container by passing the container as the last argument in their constructor.</p>
<p><a class="el" href="classWt_1_1WCompositeWidget.html" title="A widget that hides the implementation of composite widgets.">WCompositeWidget</a> requires to set the implementation widget, which is in our case a <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a>:</p>
<div class="fragment"><div class="line">  setImplementation(std::move(impl));</div></div><!-- fragment --><p>We declare the slots showIcon1() and showIcon2() as stateless slots, allowing for client-side optimisation, and offer an undo function which facilitates a PreLearned client-side implementation.</p>
<p>The calls to <a class="el" href="classWt_1_1WObject.html#adaa163b9e92933f3b2ff4ec58e2734c6" title="Declares a slot to be stateless and learn client-side behaviour on first invocation.">WObject::implementStateless()</a> state that the slots showIcon1() and showIcon2() are stateless slots, and their visual effect may be learned in advance. The effect of these statements is merely an optimization. Any non-visual effects of these slots are still propagated and executed, as expected.</p>
<div class="fragment"><div class="line"></div><div class="line">  implementStateless(&amp;IconPair::showIcon1, &amp;IconPair::undoShowIcon1);</div><div class="line">  implementStateless(&amp;IconPair::showIcon2, &amp;IconPair::undoShowIcon2);</div></div><!-- fragment --><p>Next, we declare the widget to be an inline widget. An inline widget will be layed out following the natural flow of text (left to right). This does not really matter for our example, since TreeNode will do the layout with a <a class="el" href="classWt_1_1WTable.html" title="A container widget which provides layout of children in a table grid.">WTable</a>, but we do so to provide consistency with a <a class="el" href="classWt_1_1WImage.html" title="A widget that displays an image.">WImage</a> which is also inline by default.</p>
<div class="fragment"><div class="line">  setInline(true);</div></div><!-- fragment --><p>The initial state is to show the first icon:</p>
<div class="fragment"><div class="line">  icon2_-&gt;hide();</div></div><!-- fragment --><p>To react to click events, we connect signals with slots:</p>
<div class="fragment"><div class="line"></div><div class="line">  if (clickIsSwitch) {</div><div class="line">    icon1_-&gt;clicked().connect(icon1_, &amp;WImage::hide);</div><div class="line">    icon1_-&gt;clicked().connect(icon2_, &amp;WImage::show);</div><div class="line"></div><div class="line">    icon2_-&gt;clicked().connect(icon2_, &amp;WImage::hide);</div><div class="line">    icon2_-&gt;clicked().connect(icon1_, &amp;WImage::show); //</div></div><!-- fragment --><p>We change the cursor to a pointer to hint that clicking these icons may do something useful.</p>
<div class="fragment"><div class="line"></div><div class="line">    decorationStyle().setCursor(Cursor::PointingHand);</div><div class="line">  }</div><div class="line">} //</div></div><!-- fragment --><p>We also change the cursor to a pointer to hint that clicking these icons will in fact perform an action.</p>
<p>The rest of the class definition is:</p>
<div class="fragment"><div class="line"></div><div class="line">void IconPair::setState(int num)</div><div class="line">{</div><div class="line">  if (num == 0) {</div><div class="line">    icon1_-&gt;show();</div><div class="line">    icon2_-&gt;hide();</div><div class="line">  } else {</div><div class="line">    icon1_-&gt;hide();</div><div class="line">    icon2_-&gt;show();</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">int IconPair::state() const</div><div class="line">{</div><div class="line">  return (icon1_-&gt;isHidden() ? 1 : 0);</div><div class="line">}</div><div class="line"></div><div class="line">void IconPair::showIcon1()</div><div class="line">{</div><div class="line">  previousState_ = (icon1_-&gt;isHidden() ? 1 : 0);</div><div class="line">  setState(0);</div><div class="line">}</div><div class="line"></div><div class="line">void IconPair::showIcon2()</div><div class="line">{</div><div class="line">  previousState_ = (icon1_-&gt;isHidden() ? 1 : 0);</div><div class="line">  setState(1);</div><div class="line">}</div><div class="line"></div><div class="line">void IconPair::undoShowIcon1()</div><div class="line">{</div><div class="line">  setState(previousState_);</div><div class="line">}</div><div class="line"></div><div class="line">void IconPair::undoShowIcon2()</div><div class="line">{</div><div class="line">  setState(previousState_);</div><div class="line">} //</div></div><!-- fragment --><p>Note the implementations of undoShowIcon1() and undoShowIcon2(): they simply, but accurately, reset the state to what it was before the respective showIcon1() and showIcon2() calls.</p>
<h1><a class="anchor" id="treenode_sec"></a>
TreeNode: an expandable tree node.</h1>
<p>TreeNode contains the implementation of the tree, as a hierarchy of tree nodes. The layout of a single node is done using a 2x2 <a class="el" href="classWt_1_1WTable.html" title="A container widget which provides layout of children in a table grid.">WTable</a>:</p>
<pre class="fragment">|-----------------------|
| +/- | label           |
|------------------------
|     | child1          |
|     | child2          |
|     | child3          |
|     |       ...       |
|-----------------------| </pre><p>The TreeNode manages a list of child nodes in a <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a> which will be hidden and shown when the node is expanded or collapsed, and children are collapsed when the node is expanded.</p>
<p>This is the TreeNode class definition:</p>
 </p><div class="fragment"><div class="line">class TreeNode : public WCompositeWidget</div><div class="line">{</div><div class="line">public:</div><div class="line">  /*! \brief Construct a tree node with the given label.</div><div class="line">   *</div><div class="line">   * The label is formatted in a WText with the given formatting.</div><div class="line">   * The labelIcon (if not 0) will appear next to the label and its state</div><div class="line">   * will reflect the expand/collapse state of the node.</div><div class="line">   *</div><div class="line">   * Optionally, a userContent widget may be associated with the node.</div><div class="line">   * When expanded, this widget will be shown below the widget, but above</div><div class="line">   * any of the children nodes.</div><div class="line">   */</div><div class="line">  TreeNode(const std::string labelText,</div><div class="line">           TextFormat labelFormat,</div><div class="line">           std::unique_ptr&lt;IconPair&gt; labelIcon);</div><div class="line"></div><div class="line">  /*! \brief Adds a child node.</div><div class="line">   */</div><div class="line">  void addChildNode(std::unique_ptr&lt;TreeNode&gt; node);</div><div class="line"></div><div class="line">  /*! \brief Removes a child node.</div><div class="line">   */</div><div class="line">  void removeChildNode(TreeNode *node, int index);</div><div class="line"></div><div class="line">  /*! \brief Returns the list of children.</div><div class="line">   */</div><div class="line">  const std::vector&lt;TreeNode *&gt;&amp; childNodes() const { return childNodes_; }</div><div class="line"></div><div class="line">  /*! \brief Collapses this node.</div><div class="line">   */</div><div class="line">  void collapse();</div><div class="line"></div><div class="line">  /*! \brief Expands this node.</div><div class="line">   */</div><div class="line">  void expand();</div><div class="line"></div><div class="line">private:</div><div class="line">  //! List of child nodes.</div><div class="line">  std::vector&lt;TreeNode *&gt;   childNodes_;</div><div class="line"></div><div class="line">  //! The parent node.</div><div class="line">  TreeNode                 *parentNode_;</div><div class="line"></div><div class="line">  //! Layout (2x2 table).</div><div class="line">  WTable                   *layout_;</div><div class="line"></div><div class="line">  //! The icon for expanding or collapsing.</div><div class="line">  IconPair                 *expandIcon_;</div><div class="line"></div><div class="line">  //! The single image shown instead of the expand/collapse icon when no children.</div><div class="line">  WImage                   *noExpandIcon_;</div><div class="line"></div><div class="line">  //! The icon next to the label.</div><div class="line">  IconPair                 *labelIcon_;</div><div class="line"></div><div class="line">  //! The children count &#39;(x)&#39; for x children.</div><div class="line">  WText                    *childCountLabel_;</div><div class="line"></div><div class="line">  //! The container in which the children are managed.</div><div class="line">  WContainerWidget         *expandedContent_;</div><div class="line"></div><div class="line">  //! Adjust the expand icon</div><div class="line">  void adjustExpandIcon();</div><div class="line"></div><div class="line">  //! Returns if is the last child within its parent (is rendered differently)</div><div class="line">  bool isLastChildNode() const;</div><div class="line"></div><div class="line">  //! Rerender when children have changed.</div><div class="line">  void childNodesChanged();</div><div class="line"></div><div class="line">  //! Was collapsed (for undo of prelearned collapse() and expand() slots.</div><div class="line">  bool wasCollapsed_;</div><div class="line"></div><div class="line">  //! Undo function for prelearning collapse()</div><div class="line">  void undoCollapse();</div><div class="line"></div><div class="line">  //! Undo function for prelearning expand()</div><div class="line">  void undoExpand();</div><div class="line"></div><div class="line">  //! Two sets of images, for a normal node, and for the last node.</div><div class="line">  enum ImageIndex { Middle = 0, Last = 1 };</div><div class="line"></div><div class="line">  static std::string imageLine_[];</div><div class="line">  static std::string imagePlus_[];</div><div class="line">  static std::string imageMin_[];</div><div class="line">}; //</div></div><!-- fragment --><p>The public interface of the TreeNode provides methods to manage its children, and two public slots to expand or collapse the node. Remember, a slot is nothing more than a method (and the public slots: does not actually mean anything, except providing a hint to the user of this class that these methods are made to be connected to signals).</p>
<p>We start with the implementation of the constructor:</p>
 </p><div class="fragment"><div class="line">TreeNode::TreeNode(const std::string labelText,</div><div class="line">                   TextFormat labelFormat,</div><div class="line">                   std::unique_ptr&lt;IconPair&gt; labelIcon)</div><div class="line">  : parentNode_(nullptr),</div><div class="line">    labelIcon_(labelIcon.get())</div><div class="line">{</div></div><!-- fragment --><p>We start with declaring stateless implementations for the slots. It is good practice to do this first, since it must be done before any connections are made to the slots.</p>
<div class="fragment"><div class="line">  // pre-learned stateless implementations ...</div><div class="line">  implementStateless(&amp;TreeNode::expand, &amp;TreeNode::undoExpand);</div><div class="line">  implementStateless(&amp;TreeNode::collapse, &amp;TreeNode::undoCollapse);</div></div><!-- fragment --><p>We will implement the treenode as 2 by 2 table.</p>
<div class="fragment"></div><!-- fragment --><p>We create all icons. Since currently the node is empty, we only show the no-expand version (which is simply a horizontal line).</p>
<div class="fragment"></div><!-- fragment --><p>The expanded content is a <a class="el" href="classWt_1_1WContainerWidget.html" title="A widget that holds and manages child widgets.">WContainerWidget</a>.</p>
<div class="fragment"></div><!-- fragment --><p>We create the label and child count text widgets:</p>
<div class="fragment"></div><!-- fragment --><p>Now we add all widgets in the proper table cell, and set the correct alignment.</p>
<div class="fragment"></div><!-- fragment --><p>Finally, we connect the click events of the expandIcon to the expand and collapse slots.</p>
<div class="fragment"></div><!-- fragment --><p><a class="el" href="classWt_1_1WTable.html#abb23850096316e37d2b77dced200514a" title="Accesses the table element at the given row and column.">WTable::elementAt(int row, int column)</a> is used repeatedly to add or modify contents of the table cells, expanding the table geometry as needed. Finally, we make connections from the expand and collapse icons to the slots we define in the TreeNode class.</p>
<p>Again, we optimize the visual effect of expand() and collaps() in client-side JavaScript, which is possible since they both have an effect independent of application state. Typically, one will start with a default dynamic slot implementation, and indicate stateless implementations where desired and possible, using one of the two mechanisms of stateless slot learning.</p>
<p>The "business logic" of the TreeNode is simply to manage its children. Whenever a child is added or removed, adjustments to its look are updated by calling childNodesChanged().</p>
<div class="fragment"></div><!-- fragment --><p>The expand icon of the last child is rendered differently, as it needs to terminate the vertical guide line. To keep the implementation simple, we simply let every child reset its proper look by calling adjustExpandIcon().</p>
<div class="fragment"></div><!-- fragment --><p>When getting a first child, or losing the last child, the expand icon changes too.</p>
<div class="fragment"></div><!-- fragment --><p>We also update the childCount label.</p>
<div class="fragment"></div><!-- fragment --><p>Finally, we call <a class="el" href="classWt_1_1WObject.html#a92d8b00edc79b7a60d41d7c088f50436" title="Resets learned stateless slot implementations.">WObject::resetLearnedSlots()</a>. Because the expand() slot depends on the number of children, because it needs to collapse all children &ndash; this slot is not entirely stateless, breaking the contract for a stateless slot. However, we can get away with still implementing as a stateless slot, by indicating when the state has changed.</p>
<div class="fragment"></div><!-- fragment --><p>The implementation of the collapse slot is as follows:</p>
<div class="fragment"></div><!-- fragment --><p>First we record the current state, so the undo method can exactly undo what happened.</p>
<div class="fragment"></div><!-- fragment --><p>Next, we implement the actual collapse logic:</p>
<div class="fragment"></div><!-- fragment --><p>Similarly, the implementation of the expand slot. However, in this case we need to collapse all children as well.</p>
<div class="fragment"></div><!-- fragment --><p>Since we implement these slots as prelearned stateless slots, we also need to define the undo functions. Note that Because expand() also collapses all child nodes, the undo function of expand() is not simply collapse() and vice-versa.</p>
<div class="fragment"></div><!-- fragment --><p>Finally, the adjustExpandIcon() function sets the correct images, which depends on how the node relates to its siblings. The last node looks a bit different.</p>
<div class="fragment"></div><!-- fragment --><p>We set the expand icon images:</p>
<div class="fragment"></div><!-- fragment --><p>Then, we set the vertical guide line if not the last child, and nothing if the last child:</p>
<div class="fragment"></div><!-- fragment --><p>Finally, we select the correct icon, depending on whether the node has children:</p>
<div class="fragment"></div><!-- fragment --><p>And that's it. By using the TreeNode class in a hierarchy, we can create a tree widget. The tree widget will be implemented entirely in JavaScript, if available, and otherwise as plain HTML. In any case, client-side and server-side state are completely synchronized, and identical by definition since they are derived from the same C++ code. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<hr size="1"><address style="text-align: right; margin: 3px"><small>
Generated on Wed Apr 22 2020 for <a href="http://www.webtoolkit.eu/wt">the
C++ Web Toolkit (Wt)</a> by&nbsp;<a
href="http://www.doxygen.org/index.html"><img src="doxygen.png"
alt="doxygen" border="0" style="vertical-align: middle; display:
inline-block; height: 2em"></a> 1.8.15</small></address>
</body>
</html>

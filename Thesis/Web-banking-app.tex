\documentclass[a4paper,12pt]{book}
\usepackage{xcolor}
\usepackage{etoc}
\usepackage{soul}
\usepackage{blindtext}
\usepackage{scrextend}
\usepackage[utf8]{inputenc}
\usepackage[USenglish,british,american,australian,english]{babel}
\usepackage{helvet}
\usepackage{graphicx}
\usepackage{color}
\usepackage{geometry}
\usepackage{regexpatch,fancyvrb,xparse}
\usepackage{listings}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\lstset{
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{green}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red} % string color
}


\makeatletter
\let\do@footnotetext\@footnotetext
\regexpatchcmd{\do@footnotetext}
  {\c{insert}\c{footins}\cB.(.*)\cE.}
  {\1\c{egroup}}
  {}{}
\def\@footnotetext{\insert\footins\bgroup\@makeother\#\do@footnotetext}
\newcommand{\ttvar}{\begingroup\@makeother\#\@ttvar}
\newcommand{\@ttvar}[1]{\ttfamily\detokenize{#1}\endgroup}
\makeatother
\newcommand\tab[1][1cm]{\hspace*{#1}}
\geometry{hmargin={2cm, 2cm}, height=10.0in}

\begin{document}
\thispagestyle{empty}
%% ------------------------ NAGLOWEK STRONY ---------------------------------
\includegraphics[height=37.5mm]{agh_nzw_a_en_1w_wbr_pms}\\
\rule{30mm}{0pt}{
{\large \textsf{Faculty of Physics and Applied Computer Science}}\\
\rule{\textwidth}{3pt}\\
\rule[2ex]
{\textwidth}{1pt}\\
\vspace{7ex}
\begin{center}
{\LARGE \bf \textsf{Engineering thesis}}\\
\vspace{13ex}
% --------------------------- IMIE I NAZWISKO -------------------------------
{\bf \Large \textsf{Michal Stefaniuk}}\\
\vspace{3ex}
{\small \sf major: {\bf \textsf{applied computer science}}}\\
\vspace{1.5ex}
%{\small \sf specialisation: {\bf \textsf{software engineering}}}\\
\vspace{10ex}
%% ------------------------ TYTUL PRACY --------------------------------------
{\bf \huge \textsf{Web application developement using WebToolkit
C++ on the example of a banking service}}\\
\vspace{14ex}
%% ------------------------ OPIEKUN PRACY ------------------------------------
{\Large \sf Supervisor: {\bf \textsf{Dr Grzegorz Gach}}}\\
\vspace{22ex}
{\large \bf \textsf{Cracow, June 2021}}
\end{center}
%% =====  STRONA TYTULOWA PRACY MAGISTERSKIEJKIEJ ====

\newpage

\begin{center}
	{\bf\large\textsf{OÅ›wiadczenie studenta}}\\
\end{center}

%% ===== PL TYL STRONY TYTULOWEJ PRACY MAGISTERSKIEJKIEJ ====
{Uprzedzony(-a) o odpowiedzialnosci karnej na podstawie art. 115 ust. 1 i 2 ustawy z dnia 4 lutego 1994 r. o prawie autorskim i prawach pokrewnych (t.j. Dz. U. z 2018 r. poz. 1191 z pozn. zm.): ,,Kto przywlaszcza sobie autorstwo albo wprowadza w blad co do autorstwa calosci lub czesci cudzego utworu albo artystycznego wykonania, podlega grzywnie, karze ograniczenia wolnosci albo pozbawienia wolnosci do lat 3. Tej samej karze podlega, kto rozpowszechnia bez podania nazwiska lub pseudonimu tworcy cudzy utwor w wersji oryginalnej albo w postaci opracowania, artystyczne wykonanie albo publicznie znieksztalca taki utwor, artystyczne wykonanie, fonogram, wideogram lub nadanie.", a takze uprzedzony(-a) o odpowiedzialnosci dyscyplinarnej na podstawie art. 307 ust. 1 ustawy z dnia 20 lipca 2018r. Prawo o szkolnictwie wyzszym i nauce (Dz. U. z 2018 r. poz. 1668 z pozn. zm.) ,,Student podlega odpowiedzialnosci dyscyplinarnej za naruszenie przepisow obowiazujacych w uczelni oraz za czyn uchybiajacy godnosci studenta.", oswiadczam, ze niniejsza prace dyplomowa wykonalem(-am) osobiscie i samodzielnie i nie korzystalem(-am) ze zrodel innych niz wymienione w pracy.

\bigskip

Jednoczesnie Uczelnia informuje, ze zgodnie z art. 15a ww. ustawy o prawie autorskim i prawach pokrewnych Uczelni przysluguje pierwszenstwo w opublikowaniu pracy dyplomowej studenta. Jezeli Uczelnia nie opublikowala pracy dyplomowej w terminie 6 miesiecy od dnia jej obrony, autor moze ja opublikowac, chyba ze praca jest czescia utworu zbiorowego. Ponadto Uczelnia jako podmiot, o ktorym mowa w art. 7 ust. 1 pkt 1 ustawy z dnia 20 lipca 2018 r. Prawo o szkolnictwie wyzszym i nauce (Dz. U. z 2018 r. poz. 1668 z po 'zn. zm.), moze korzystac bez wynagrodzenia i bez koniecznosci uzyskania zgody autora z utworu stworzonego przez studenta w wyniku wykonywania obowiazkow zwiazanych z odbywaniem studiow, udostepniac utwor ministrowi wlasciwemu do spraw szkolnictwa wyzszego i nauki oraz korzystac z utworow znajdujacych sie w prowadzonych przez niego bazach danych, w celu sprawdzania z wykorzystaniem systemu antyplagiatowego. Minister wlasciwy do spraw szkolnictwa wyzszego i nauki moze korzystac z prac dyplomowych znajdujacych sie w prowadzonych przez niego bazach danych w zakresie niezbednym do zapewnienia prawidlowego utrzymania i rozwoju tych baz oraz wspolpracujacych z nimi systemow informatycznych.}\\

\bigskip

\newpage
\tableofcontents

\chapter*{Introduction}
\addcontentsline{toc}{section}{\protect\numberline{}Introduction}%
\tab {Software engineering is a very wide area of engineering which particularly concerns developing and maintaining programming products. A development process itself is a major challenge to all people involved, starting with engineers creating the code, continuing with product owners who are managing teams and coordinating the work flow and ending-up with managers who are setting the direction of the whole process.

\bigskip
The main motivation to create this thesis was simply to present a development process that includes basic and nowadays necessary tools which are significantly helpful in such process. Simultaneously creating a C++ web application was an equally important factor. To carry out the development and present all tools it was decided that an example C++ web application will be created with a GUI library in modern C++ called \textbf{Web Toolkit}. 

\bigskip 
Nowadays in a software engineering world there is a trend to migrate desktop applications to the internet, which has also impacted a lot GUI desktop libraries in decreasing their utilities. The secondary reason behind choosing C++ to create a web application, which is quite unusual, was to show the tremendous possibilities that this language still provides and to exhibit the capabilities of open source libraries shared among developers and engineers. The bottom line is - next chapters are a review of possibilities that C++-based web library provides.
}

\chapter{Projects assumptions}

\section{Application's blue-print}
{
The application is a single-page service run on a local server with an \textbf{http://localhost:8080/} address. After starting, logging panel appears, giving the user an opportunity to type their credentials and log-in. 

\bigskip
The idea of the service is to provide basic functionalities of a banking service like for instance transferring money or checking their balance to the user. These required implementation of secure back-end layer with a database containing information about the users and transactions and a front-end layer which is transparent to the user. 

\bigskip
Regarding the credentials a user will see different features after logging into the service. There might be many accounts created and held up in the database of the service but there are only two rights of access.}\\
\begin{labeling}{alligator}
\item [\textbf{USER}] Transferring money and seeing current account's balance.
\item [\textbf{ADMIN}] Seeing details about every account in the service as well as having access to the logs from the application.
\end{labeling}

\bigskip
After user decides to quit the service, a possibility of logging out is provided and whilst doing that the application returns to the logging page where session is refreshed and database is updated. If the user was an administrator of the service, an access to the console logs that are gathering and sniffing network traffic like HTTP methods for RESTful APIs is also granted.  

\section{Programming environment}
{\tab Developing any kind of programs usually requires specific environmental variables therefore a programmer's task is to choose a specific set of tools which will be the most handy during the process.  

\bigskip
Regarding the specifics of the project, the chosen set of tools looks like following:
\begin{labeling}{alligator}
\item [\textbf{IDE}] Microsoft Visual Studio Community 2019,
\item [\textbf{LIBRARY}] Web Toolkit 4.3.1,
\item [\textbf{LIBRARY}] Boost C++ lib [latest version],
\item [\textbf{TOOL}] CMake VERSION 2.4,
\item [\textbf{TOOL}] Git BASH.
\end{labeling}}

The application was developed under Windows 10 64-bit operating system, but it could have been developed under any other platform that is supported by WebToolkit library.

\newpage
\subsection*{IDE - Integrated Development Environment}
{
\tab IDE is a program or a set of programs merged into one that usually gathers tools, libraries, debuggers, run time scripts and any other stuff necessary for the developer to write the code. The purpose of IDE is to allow easily and swiftly create code, but at the same time test it, compile it and run it in one place. 

\bigskip
The advantage of this solution is that it gives the developer an opportunity to set up and scale his development environment adjusting it to the project needs. Usually IDE, as well as modern text editors, also support plugins which are nice addition to the program, like for instance syntax highlighters, semantics hints, code analyzers or refactoring scripts.

\bigskip
The chosen IDE for this project is \textbf{Microsoft Visual Studio Community 2019}. Web Toolkit library is supported on various platforms including Linux distributions (even less popular ones like ArchLinux, Slackware or Opensuse), Windows or other operating systems like Android, Raspberry Pi or even OS X. The consequence of choosing MSV IDE was using Windows platform and prebuilt Windows binaries of the WT library.

\bigskip
\textbf{Microsoft Visual Studio} is an IDE produced by Microsoft Company and it allows creating cross-platform software with graphical user interface. It basically supports every programming language but the basic package contains support for 
\begin{itemize}
	\item Microsoft Visual C,\ttvar{#}
	\item Microsoft Visual C++,
	\item Microsoft Visual Basic,
	\item Microsoft Visual J,\ttvar{#}
	\item Microsoft Visual Web Developer ASP.NET,
	\item Microsoft Visual F.\ttvar{#}
\end{itemize}

Microsoft Visual Studio (MSVC) also provides a lot of built-in features. Many of them occurred to be significantly useful in the process of developing this application. A few most important ones are
\begin{itemize}
	\item debugger, linker and compiler,
	\item projects and build systems,
	\item writing and refactoring C++ code,
	\item code analysis overview,
	\item unit tests support,
	\item universal windows apps like command line appliactions.
\end{itemize}

}

\subsubsection*{Boost C++ library}
{
\tab Boost is a collection of C++ libraries that enhances capabilities of C++ code development, which is also licensed by \textbf{Boost Software License}. For the project Boost is necessary to build Web Toolkit library as it's implementation uses Boost functionalities.

\bigskip
The most important features provided by Boost are
\begin{itemize}
	\item algorithms,
	\item concurrent programming,
	\item complex containers,
	\item correctness validating and enhanced unit testing,
	\item additional data structures (like bimap, fusion, tuple etc),
	\item high level programming and functional objects,
	\item parsers and graphs,
	\item meta-programming with templates.
\end{itemize}
	
Boost library as a collection is not used in this project explicitly, as the application was developed in Microsoft Visual Studio environment with pre-built Windows binaries. However, for automation server, the project is built with linux machine where WebToolkit needs to be built manually, therefore boost is required.
}
\subsubsection*{CMake}
{
\tab CMake is a cross platform tool that provides automatic management of compiler that builds the code of an application. It's role is to create a configuration for project files of popular programming environments, which then are used in a process of compilation. The main advantage of using CMake is it's independence of the compiler and the platform. Moreover CMake as a standalone program creates files with rules for compilation dedicated to another program like IDE and it forms a unified building environment. CMake stands for \textit{Cross-platform Make}.

\bigskip
The most important features provided by CMake are
\begin{itemize}
	\item platform independence,
	\item cross compilation,
	\item out-of-source building,
	\item building projects with complex catalog structure,
	\item unit testing support,
	\item detecting dependencies and outer libraries.
\end{itemize}
This project required including CMake tool because of various dependencies and complex building due to including Web Toolkit and Boost.  

\bigskip
To be able to explore favors that CMake offers one must create \textbf{CMakeLists.txt} file placed in the desired catalog of the project. The core of this file is a simple scripting language that describes rules and defines variables telling the compiler how to link files and what should be the outcome of the compilation process.

\bigskip
Let's have an example project\cite{cmakeintroduction} which structure looks like below.\newline
\begin{lstlisting}[frame=single, language=C++, caption={Example CMake project structure.}, captionpos=b]
 .
 |-- CMakeLists.txt
 |-- build
 |-- include
 |   \-- Student.h
 \-- src
     |-- Student.cpp
     \-- mainapp.cpp
\end{lstlisting}

\bigskip
The content of \textbf{*.cpp} and \textbf{*.h} files is irrelevant here, at this point it could be any code. In the main directory there is a simple \textbf{CMakeLists.txt} which is used to build the project. The code of the \textbf{CMakeLists} script:\newline

\begin{lstlisting}[frame=single, language=C++, caption={CMakeLists.txt of example project.}, captionpos=b]
cmake_minimum_required(VERSION 2.8.9)
project(directory_test)

#Specifies include directories to use when compiling a given target
include_directories(include)

#Can manually add the sources using the set command as follows:
#set(SOURCES src/mainapp.cpp src/Student.cpp)

#However, the file(GLOB...) allows for wildcard additions:
file(GLOB SOURCES "src/*.cpp")

add_executable(testStudent ${SOURCES})
\end{lstlisting}
\bigskip
The most important things while building the project that above CMake will perform (in order from the top) are
\begin{itemize}
	\item Include directories to specify headers files directories
	\item Sources are also set, but the line is commented out as each file needs to be manually added in place
	\item file() command to add source files to project's GLOB SOURCES
	\item add\_executable() which uses SOURCES variable in order to build executable program
\end{itemize}


\noindent Now to invoke building using CMake:
\begin{lstlisting}[language=bash]
  $ cd build
  $ cmake ..
  $ make
  $ ./testStudent
\end{lstlisting}
  
\bigskip First current directory is changed to build, where output files will be stored. From there cmake will create \textbf{Makefile} containing references to all sources and headers, which ultimately will create an executable that is ready to be run. This as a very basic example of how \textbf{CMake} works. In next chapters there will be more details about \textbf{CMake} and what is the main concept behind basing on the one used in project. 

}

\chapter{WebToolkit C++ library}
\section{Library overview}
{\tab \textbf{Web Toolkit} is an open-source C++ library that allows developers to create Single Page web applications without writing single line of JavaScript code. The main concept behind SAP~\cite{singlepageapplications}(\hl{Single Page Applications}) is they do not render HTML files, but instead they use asynchronous JavaScript to reload contents of the page in real time without refreshing the whole page. To some extent it might be a bit misleading, as with loading different content, the URL of the page changes as well, like in ordinary multi-page service.

\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{spa}
    \caption{Traditional Page vs SPA.}
\end{figure}

\bigskip
As a SPA, web-banking application works on widgets which are the core of WebToolkit library. A widget itself is a specific type of user-computer interaction with a graphical interface such as button or a scroll bar, which in WebToolkit case is wrapped in C++ code. A developer should create a main widget, which is not visible to the user. Instead it works as a widget container that will hold other template widgets that will be plugged in or plugged out depending on what content will be loaded on the page.  

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{spa-template}
\caption{Views in Traditional Page and SPA[2].}
\end{figure} 

\bigskip
There are a lot of modern services that use SPA technology like facebook~\cite{facebook}, airbnb~\cite{airbnb}, twitter~\cite{twitter}, paypal~\cite{paypal}, gmail~\cite{gmail} or even netflix~\cite{netflix}. The biggest benefits of this web application model are quick loading time, good caching abilities, improved user experiance or rapid front-end development. 

\bigskip
The most important thing about Single Page Application model is very rapid and fast user experience as the page does not refresh or re-render. However, since the page works on widgets usually the HTML contents of the page is rather empty. Often it's just a few tags, scripts and imports while the rest of the contents is loaded dynamically for instance by asynchronous javascript. This is a big disadvantage when it comes to search engines that are using crawlers. Instead of seeing the web contents they will see a short HTML file with not too much to process, since crawlers never wait for asynchronously loaded data. This SEO problem makes Single Page applications a bad choice for services relying on search engines and positioning.

\bigskip
On the other hand a regular static page has a lot to offer too. It servers HTML file instantly, but it requires refreshing and rendering new page. It reduces the amount of javascript code that is needed but it also allows crawlers to see the same content that users can see. The disadvantage of this type of page should be pretty obvious now - it allows to create services with limited dynamic content. It might be a poor choice to go for when a service needs to serve content that changes quite frequently.


\bigskip
Beyond usual frameworks dedicated for SPA services are
\begin{itemize}
	\item Angular.js,
	\item React.js,
	\item Backbone.js,
	\item Ember.js.
\end{itemize}

It is no secret that preferable programming technology stack for such development would be JavaScript~\cite{javascript}, TypeScript~\cite{typescript}, HTML~\cite{html}, CSS~\cite{css} and some back-end in Java~\cite{java}, Python~\cite{python} or PHP~\cite{php}. With that being said, WebToolkit library seems to be very unorthodox tool for this task. The whole development process starts and ends with C++ code, which makes it interesting and unusual.

\newpage

}
\section{WebToolkit Features}
{
\tab \textbf{Web Toolkit} library has a lot to offer. Now of course - creating web application in C++ language comes with a prize. It's biggest disadvantage is that while programming we have no control of HTML code. There is also a necessity of re-compiling the code with every change introduced where there is no such need when using standard web development tools (like javascript application with node.js or php application with XAMPP). However, having said that it is worth mentioning that Web Toolkit is appreciated for plenty features that it provides to the users.
 
\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\textwidth]{features}
    \caption{WebToolkit logo and features~\cite{wtlogo}.}
\end{figure}

\subsection*{Core Library} 
{
\tab What is really important is that core library is fully open source and still under development. It's implementation allows to integrate it with third party JavaScript libraries, which is a nice addition for developers that create services with more advanced front-end layer. What is more, Web Toolkit is fully compatible with HTML5~\cite{html5} and HTML4~\cite{html4} browsers. Thus, as a hybrid single page framework it supports browser history navigation. The bottom line is, WT is a high performance library which is something you would expect from a C++ library. It is optimized when it comes to asynchronous I/O, multi-threading and throughout all rendering.

\bigskip
Event handling is completed with C++11 lambdas~\cite{lambda} or bound object methods to retreive data that is bound to a function. Those are a part of C++11 signal/slot API for responding to various events. Server-initiated updates are also available through WebSockets and automatic fallaback to AJAX. Event handling itself is also completed with efficient synchronization of browser using session, which incrementally renders updates of application states.

\bigskip
Core library also provides 2D and 3D painting support to users and developers. Through Web Toolkit API it is possible to generate simple graphics objects like HTML5 canvas, inline SVG~\cite{svg} or inline VML. Graphics is also leveraged by rendering common image formats like PNG, GIF or even PDF. WT broads the variety of graphics support by also supporting hardware-accelerated 3D painting API like for instance server-side OpenGL~\cite{opengl}.
}

\subsection*{Security}
{
\tab As a completed web-development library, WebToolkit provides built-in security layer to the applications which contains:

\begin{itemize}
	\item kernel-level memory protection in isolated sessions,
	\item TLS/SSL support,
	\item Cross-Site Scripting (XSS) prevention,
	\item Request Forgery (CSRF) prevention,
	\item Application logic attack prevention,
	\item DoS mitigation,
	\item \textbf{Authentication module} (including support for OAuth 2.0 and OpenID Connect).
\end{itemize}

\begin{figure}[h]
  \centering
    \includegraphics[width=1.1\textwidth]{auth-module}
    \caption{Main classes of the authentication module\cite{authmodule}.}
\end{figure}

The authentication module itself occurred to be significantly important and helpful in Web Banking Application. Some of the classes which implement basic user features are presented above. What it means is that secure and robust service functionalities like signing in/out, registration or authentication are already provided.

}

\subsection*{Database support}
{
\tab As any other modern library, WT supports databases with a sub-library called Wt::Dbo, which by implementing ORM (Object-Relational Mapper) becomes a convenient way to communicate C++ application with SQL databases. What is more, Wt::Dbo as a self-contained sub-library is independent from Wt itself, which means it could be used for standalone back-end service. Other basic Wt::Dbo features are: 

\begin{itemize}
	\item Support for
	\begin{itemize}
     \item Sqlite3
     \item Firebird
     \item MariaDB
     \item MySQL
     \item SQL Server
     \item PostgreSQL
     \end{itemize}
	\item Native SQL to query objects and fields
	\item Session with first-level cache
	\item DB transactions
	\item CRUD operations
	\item Many-to-One and Many-to-Many relations
	\item Just C++ without XMLs or Macros

\end{itemize}
}

\subsection*{Deployment}
{
\tab Extremely important thing in any application is process of Deployment. WT through various abstract interfaces connects with outer world. The basic one is built-in httpd but among others:

\begin{itemize}
	\item Built-in \textbf{HTTPD}
	\begin{itemize}
     \item Simple and high performance with multithreading and asynchronous I/O based on C++ asio library
     \item Supports WebSockets and HTTP(s) with chunking and compression
     \item Available for many platforms like Linux, Windows and any UNIX like systems
     \end{itemize}
	\item \textbf{FASTCGI}
	\begin{itemize}
     \item Integrated with common web servers like apache
     \item Supported for Linux and UNIX
     \end{itemize}
	\item \textbf{ISAPI}
	\begin{itemize}
     \item Integrated with Microsoft IIS server
     \item Completed with asynchronous API
     \item Supported for Windows
     \end{itemize}
\end{itemize}
}
\newpage
}

\section{Hello World Application}
{
Lets go through simple Hello World applications just to get in touch with WebToolkit library environment.

\begin{lstlisting}[frame=single, basicstyle=\small, language=C++, caption={A complete "Hello world" application \cite{helloworldapp}.}, captionpos=b]
#include <Wt/WBreak.h>
#include <Wt/WContainerWidget.h>
#include <Wt/WLineEdit.h>
#include <Wt/WPushButton.h>
#include <Wt/WText.h>

class HelloApplication : public Wt::WApplication
{
public:
    HelloApplication(const Wt::WEnvironment& env);

private:
    Wt::WLineEdit *nameEdit_;
    Wt::WText *greeting_;
};

HelloApplication::HelloApplication(const Wt::WEnvironment& env)
    : Wt::WApplication(env)
{
    setTitle("Hello world");

    root()->addWidget(std::make_unique<Wt::WText>("Your name, please? "));
    nameEdit_ = root()->addWidget(std::make_unique<Wt::WLineEdit>());
    
    Wt::WPushButton *button = 
    	root()->addWidget(std::make_unique<Wt::WPushButton>("Greet me."));
    	
    root()->addWidget(std::make_unique<Wt::WBreak>());
    greeting_ = root()->addWidget(std::make_unique<Wt::WText>());
    
    auto greet = [this]{
      greeting_->setText("Hello there, " + nameEdit_->text());
    };
    button->clicked().connect(greet);
}

int main(int argc, char **argv)
{
    return Wt::WRun(argc, argv, [](const Wt::WEnvironment& env) {
      return std::make_unique<HelloApplication>(env);
    });
}
\end{lstlisting}

\newpage
Now when it comes to building, it could be done locally by setting up a localhost HTTP server. Having IDE set-up it is done automatically. Otherwise while operating on UNIX-like systems:

\begin{lstlisting}[frame=single, basicstyle=\small, language=C++, caption={Building "Hello world" application.}, captionpos=b]
$ g++ -std=c++14 -o hello hello.cc -lwthttp -lwt
$ ./hello --docroot . --http-address 0.0.0.0 --http-port 9090
\end{lstlisting}

\bigskip
The final result is:
\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\textwidth]{hello-app}
    \caption{Hello Application on Web Toolkit.}
\end{figure}

\bigskip
The above code presents basic concepts of the library workflow.

\begin{labeling}{alligator}
\item [\textbf{class HelloApplication}] A class that represents application and extends Wt::WApplication. Contains ctor that takes Wt::WEnvironment and private fields that represents input field and output greeting string wrapped in Wt::WText.
\item [\textbf{LINE 20:}] Sets title of appliaction which will be visible in web browser's card.
\item [\textbf{LINE 22-29:}] This part of the code handles adding widgets to the root which represents a container for the widgets. This is an implementation of SPA concept where we create widgets and plug them in or out, for instance by addWidget() function.
\item [\textbf{LINE 31:}] Lambda expression that returns WText string which is called upon clicking the button.
\item [\textbf{LINE 34:}] Calling lambda expression from line 31 when button is clicked.
\item [\textbf{MAIN:}] Creating and running application.
\end{labeling} 


}
\section{Widgets gallery}
{
\tab \textbf{Web Toolkit} also offers a widgets gallery, which is nothing else but a bootstrap where most common widgets are already implemented and ready to be used. Among them there are layouts, forms widgets, navigation widgets, trees widgets, tables widgets, graphics widgets, charts widgets and media widgets. Basically whilst going through development process one should keep in mind this feature as it may save a lot of time and a lot of coding. 

\bigskip
\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{gallery}
    \caption{Web Toolkit Widget Gallery.~\cite{widgetsgallery}.}
\end{figure}
    
     
}

\chapter{DevOps layer}
{
\tab DevOps stands for development and operations and it is a modern approach for software engineering. Its core is to integrate developer teams with other sections invloved in the process. According to this definition, devOps engineer is someone who is fluent with development cycle and it is also someone who can improve the process. Naturally there are a lot of cutting-edge tools which are significantly helpful in DevOps engineering. 

\bigskip
\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{devops}
    \caption{DevOps process.~\cite{devops}.}
\end{figure}
    
Figure 3.1 shows basic elements of devOps approach which are
\begin{itemize}
	\item building the product that is being developed,
	\item coding,
	\item planning the whole process,
	\item monitoring the development,
	\item operating,
	\item deploying for instance to cloud,
	\item releasing to client,
	\item and testing throughout the whole time.
\end{itemize} 
	
\bigskip
Creating web banking application was also about carrying out the development process based on devOps approach. 
}
\section{Distributed version-control system}}
{
\tab First tool that was used in this project was version-control system called \textbf{Git}. It is a tool that allows developers to track changes in code of the project, as well as making them. Every change introduces a new version of the code which is stored in history. The biggest advantage of this feature is capability of restoring previous version of the code which presents tremendous enhancement to reponsing to unwanted changes.

\bigskip
What is more, Git provides branching feature, which simplifies developing code simultaneously by many developers at the same time. By invoking simple command line functions developer can communicate his local repository with remote repository. Many version-control systems have graphic interfaces too.

\bigskip
\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{git}
    \caption{Distributed version-control system workflow.~\cite{git}}
\end{figure}   
}
\section{GitHub}
{
\tab Web banking application was being developed using GitHub, which is a GIT version-control system hosting dedicated for programming projects. A remote repository was stored there, which contained:

\begin{itemize}
	\item applications code,
	\item CMake building scripts,
	\item YAML docker images for automation server,
	\item web toolkit library,
	\item static resources like images,
	\item unit and regression tests,
	\item this theesis,
	\item and most importantly - information about all changes introduced to the project.
\end{itemize}
	
\bigskip
Creating this application required over 150 commits, 18 branches and more than 20 pull requests.

\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{repo}
    \caption{Web banking application github repository.~\cite{repo}}
\end{figure} 

\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\textwidth]{languages}
    \caption{Languages statistics on Web banking application repository. The majority of is HTML code, because of the static resoruces of WebToolkit library, which handle HTML.~\cite{repo}}
\end{figure} 
    
\begin{figure}[h]
  \centering
    \includegraphics[width=0.7\textwidth]{pullrequests}
    \caption{A small batch of a few pull requests done during the implementation.~\cite{repo}}
\end{figure} 
    
A pull request itself is a github feature which allows programmers to do a review of a code that has been developed during a certain amount of time and is now to be ready to be merged to the main branch of the repository, which is usually the branch that is frequently being built and released to the client. This process performs a quality gate to the code and also increases readability of the changes introduced to the product. Figure 3.5 shows a few pull requests that were put out during the development. Each one of the pull requests has its unique name, id and can be also labeled by fancy labels (like feature, bug, improvement, back-end and others) which can be modified by repository owners. Before merging, the product is being built with the upcoming changes, which is another quality gate. If the built is successful and the reviewers approved the code - a programmer is allowed to merge the code and close the pull request. Another interesting thing is that every pull request or commit may be pre-tagged with a \textbf{WBS-number}, which stands for "WebBankingApplication-number of the story" and is thoroughly explained in the next section of this chapter. 
}
\section{Proprietary issue tracking}
{
\tab Another tool that came in really handy during development is proprietary issue tracking. It is a system which reflects changes introduced to the project and ultimately allows to track and manage the progress. 
}
\subsection{JIRA Software}
{
\tab Example issue tracking system which was used in the project is JIRA Software. With its graphic user interface it can provide a projects board, which regarding Agile framework chosen in a development process, could reflect issues work flow in a different way. In the project we could group issues by those that are meant to be done, those that are being currently developed and those that are already done.

\bigskip
\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{kanban}
    \caption{JIRA Kanban board used during projects development.~\cite{jiraboard}}
\end{figure} 
    
\bigskip Kanban board is a board that reflects "waterfall" work flow, where issues are reported and resolved as development goes, without working in a frequent time rate like in Scrum where developers could work for example in two week sprint methodology. Nevertheless, before starting programming Web banking application, the whole development process needed to be thought through and planned well. After planning, issues were created and added to the board. With creating every part of the project there was an issue that reflected actual state of the task that is being worked on. Swift GUI of JIRA Software allows to easily do drag-and-drop, starting with issues in "To Do", ending up with issues in "Done" table.
    
\bigskip
In this project issues were group by
\begin{itemize}
	\item engineering thesis issues (mostly chapters),
	\item theesis improvements,
	\item application improvements,
	\item general improvements,
	\item and code of the application.
\end{itemize}
	
JIRA Software allows developers to connect project issue tracking with its repository and during this development it was no different - github repository was connectet with JIRA. What it does is it detects branches and pull requests by id in commits (mentioned in previous section) that are binded to the given story or issue. It improves managing the project work flow by allowing to track the code that was merged to accomplish particular issues. All a developer needs to do is to remember to include repository acronym in commit message as a tag. In this case it was "WBS". There is a possibility to set on a repository that commits without project tag cannot be push onto remote repository, which is guarding the quality of branching.

\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{issue}
    \caption{Adding project tags to commit messages on a repository that is connected with jira board detects the code created to resolve particular story ("Development" panel on the right).~\cite{jiraboard}}
\end{figure} 
    
\begin{figure}[h]
  \centering
    \includegraphics[width=0.5\textwidth]{applicationstory}
    \caption{Example story with subtasks.~\cite{jiraboard}}
\end{figure}
    
\bigskip
Apart from project board JIRA provides many other features like for example simple reports, that are usually presented on graphs that are available by a single click.      
Estimating due dates and development duration is also a very important part of tracking issues. However in this project only due dates were estimated  as Kanban framework does not expect estimating the duration for each issue. All in all, the project was planned for 5 stories, with around 38 subtasks. Those which were not chosen to be developed and were not completed were archived in backlog section of the board.

\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{chart1}
    \caption{Created vs Resolved Issues Report. This chart shows the number of issues created vs. the number of issues resolved in the last 100 days.~\cite{jiraboard}}
\end{figure}
    
}

\section{Automation server and regression testing}
{
\tab Software development should not be done without assuring that the quality of the product is there. Among many quality gates like code review or unit testing there is also another one equally important - regression testing. It is being run on an automation server, which usually is another software that helps to automate the building process by configuring tasks, so called "jobs". It can also be used as a documentation generator. It is a common practice to run regression testing as well, which are nothing but a functional or non-functional test scenarios that ensure that the code that is about to be merged won't have a negative impact on the product. In a nutshell - regression testing will also verify if the software that is being developed works at all the time, considering that the regression tests might be run not only when a programmer tries to modify the code, but also when the code is merged. As a matter fact, there are many testing approaches when it comes to regression. For instance - the tests that are causing the highest traffic on the automation server might be run over night or during the weekend when developers are not working. It is a very powerful tool which can have a major impact on the quality of the development.

\bigskip During implementing web banking application, an automation server was set up, which was connected to the repository where the code was stored. With each pull request, automation server took changes that were about to be merged. Then the server has been building specific branch and if the build was successful, it went to another job which was running the regression test. If every job has passed successfully, then the developer was allowed to merged the code - that is assuming that the code review was already done.

\begin{figure}[h]
  \centering
    \includegraphics[width=1.0\textwidth]{regression}
    \caption{Regression testing.~\cite{reg}}
\end{figure}

}
\subsection{GitHub CMake}
{
The automation server that was used in a project is GitHub CMake. It is basically provided by github and it's free. All it takes is to define a CMake file that describes building dependencies for the project. Automation server will fetch it and build the application on it's remote machine with Linux's Ubuntu distribution. From this point, when the application is remotely build, regression testing might be started.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\textwidth]{checks}
    \caption{When a pull request is created, automation server triggers and verifies incoming changes by building the project and running testes.}
\end{figure}
\pagebreak
\bigskip To be able to add a test case scenario, first it must be implemented. In web banking application ctest was used, which is just a part of CMake and as an executable it enables testing, adds tests, runs them and reports results.
    
\bigskip
\begin{lstlisting}[frame=single, basicstyle=\small, language=C++, caption={Example ctest file used in project. It is quite self-explanatory, if first input argument equals 0, the scenario prints 'SUCCESS' and exits with 0 status. Otherwise it prints 'FAIL' and exit with 1 status.}, captionpos=b]
#ifndef _WIN32
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("usage: test <argument>\n");
        printf("If <argument> is 0, print SUCCESS. Otherwise print FAIL.\n");
        exit(1);
    }

    if (atoi(argv[1]) == 0) {
        printf("SUCCESS\n");
        exit(0);
    }
    else {
        printf("FAIL\n");
        exit(1);
    }
}
#endif
\end{lstlisting}

\bigskip Having test implemented in place, a scenarios must be defined in CMake file, that will report the results. 
\bigskip
\begin{lstlisting}[frame=single, basicstyle=\small, language=C++, caption={Example CMakeLists file used to define scenarios. In first two lines source code file and executable are set. Then by callig add test a scenario is added with input arguments. In the next lines, set test properties will define expected behaviour.}, captionpos=b]
SET(CTEST_SRC {CTEST_SRC} ctest.cpp)
add_executable(test {CTEST_SRC})

add_test(usage_test test)
set_tests_properties(usage_test PROPERTIES WILL_FAIL TRUE)

add_test(success_test test 0)
set_tests_properties(success_test PROPERTIES PASS_REGULAR_EXPRESSION "SUCCESS")

add_test(fail_test test 1)
set_tests_properties(fail_test PROPERTIES WILL_FAIL TRUE)

add_test(fail_test_output test 1)
set_tests_properties(fail_test_output PROPERTIES PASS_REGULAR_EXPRESSION "FAIL")
\end{lstlisting}

\bigskip Including above CMakeLists file in the project will trigger running four test case scenarios with each regression run.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\textwidth]{testreg}
    \caption{Regression job responsible for running tests and verifying the results.}
\end{figure}
}
\subsubsection{Regression Docker file}
{
\tab Docker is a software that realizes the concept of virtualization at OS level. By composing a docker image, a developer is able to create precise programming environment in a container, in which it possible to run any desired application. It is a lighter way of virtualization, rather than setting up a virtual machine.      

\begin{figure}[h]
  \centering
    \includegraphics[width=0.8\textwidth]{scheme}
    \caption{Github CMake provides Linux virtual machine for the developers, where Docker container with a specific environment is set up. Web banking application does just that.}
\end{figure} 
    
\bigskip 
To set up the machine responsible for automation one must place docker file all necessary dependencies. The jobs that has been set up are: 
    
\begin{labeling}{alligator}
\item [\textbf{Set up job}] Loads Ubuntu 18.04.5 LTS operating system, prepares workflow directory and all required actions.

\item [\textbf{Run actions/checkout@v2}] Fetches the repository, gets git version and authorizes user.

\item [\textbf{Get Boost libraries}] Downloads and installs Boost.

\item [\textbf{Create build environment}] Makes build directory for output files.

\item [\textbf{Configure CMake}] Identifies compilers.

\item [\textbf{Build}] Builds the project.

\item [\textbf{Test}] Runs regressions tests.|

\item [\textbf{Post Run actions/checkout@v2}] Post job cleanup.

\item [\textbf{Complete job}] Cleaning up orphan processes.
\end{labeling} 
    
\begin{figure}[h]
  \centering
    \includegraphics[width=0.4\textwidth]{jobs}
    \caption{Github CMake jobs.}
\end{figure}  
\pagebreak
\begin{lstlisting}[frame=single, basicstyle=\small, language=C++, caption={cmake.yaml docker image used in project to set up automation server.}, captionpos=b]
name: CMake

on: [push]

env:
  BUILD_TYPE: Release

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
      
    - name: Get Boost libraries
      run: sudo apt-get install libboost-all-dev
      
    - name: Create Build Environment
      run: cmake -E make_directory ${{runner.workspace}}/build

    - name: Configure CMake
      shell: bash
      working-directory: ${{runner.workspace}}/build
      run: cmake $GITHUB_WORKSPACE -DCMAKE_BUILD_TYPE=$BUILD_TYPE

    - name: Build
      working-directory: ${{runner.workspace}}/build
      shell: bash
      run: cmake --build . --config $BUILD_TYPE

    - name: Test
      working-directory: ${{runner.workspace}}/build
      shell: bash
      run: ctest -C $BUILD_TYPE
\end{lstlisting}
}

\chapter{Implementation}
\section{Server side session}
\section{Logging panel}
\section{Database}
\section{User features}
\subsection{Transferring money}
\subsection{Checking user balance}
\section{Admin features}
\subsection{Listing all users}
\subsection{Access to server logs}
\section{Unit testing}
\chapter{Summary}
\chapter{Literature}
{
\begin{thebibliography}{9}
\bibitem{cmakeintroduction}
  Introduction to CMake,
  \emph{http://derekmolloy.ie/hello-world-introductions-to-cmake}.
  
\bibitem{singlepageapplications}
  Single Page Applications,
  \emph{https://www.excellentwebworld.com/what-is-a-single-page-application}.
  
\bibitem{wtlogo}
  WT Logo and Features,
  \emph{https://www.webtoolkit.eu/wt/features}.

\bibitem{authmodule}
  Introduction to Wt::Auth,
  \emph{https://www.webtoolkit.eu/wt/doc/tutorial/auth.html}.
  
\bibitem{helloworldapp}
  Wt Hello World Application,
  \emph{https://www.webtoolkit.eu/wt/doc/tutorial/wt.html}.

\bibitem{widgetsgallery}
  Wt Widgets Gallery,
  \emph{https://www.webtoolkit.eu/widgets/forms/}.
  
\bibitem{facebook}
  Facebook,
  \emph{https://www.facebook.com}.
  
\bibitem{airbnb}
  airbnb,
  \emph{https://www.airbnb.com}.
  
\bibitem{twitter}
  Twitter,
  \emph{https://www.twitter.com}.
  
\bibitem{paypal}
  payPal,
  \emph{https://www.paypal.com}.
  
\bibitem{gmail}
  gmail,
  \emph{https://www.gmail.com}.
  
\bibitem{netflix}
  Netflix,
  \emph{https://www.netflix.com}.

\bibitem{javascript}
  JavaScript,
  \emph{https://www.javascript.com/}.
  
\bibitem{typescript}
  TypeScript,
  \emph{https://www.typescriptlang.org/}.
  
\bibitem{html}
  HTML,
  \emph{https://www.w3schools.com/html/}.
  
\bibitem{css}
  CSS,
  \emph{https://www.w3schools.com/css/}.
 
\bibitem{java}
  Java,
  \emph{https://www.java.com/pl/}.
  
\bibitem{python}
  Python,
  \emph{https://www.python.org/}.
  
\bibitem{php}
  PHP,
  \emph{https://www.php.net/}.
  
\bibitem{html5}
  HTML5,
  \emph{https://developer.mozilla.org/pl/docs/HTML/HTML5}.
  
\bibitem{html4}
  HTML4,
  \emph{https://www.w3.org/TR/html5-diff/}.
  
\bibitem{lambda}
  C++11 lambda expressions,
  \emph{https://en.cppreference.com/w/cpp/language/lambda}.
  
\bibitem{opengl}
  OpenGL,
  \emph{https://www.opengl.org/}.
  
\bibitem{svg}
  HTML5 SVG,
  \emph{https://css-tricks.com/using-svg/}.

\bibitem{devops}
  devOps logo,
  \emph{https://www.netsparker.com/devops-security-tools/}.
  
\bibitem{git}
  Git workflow,
  \emph{https://panizkomputerem.pl/czym-jest-git/}.
  
\bibitem{repo}
  Applications github repository,
  \emph{https://github.com/michals96/web-banking-system}.   

\bibitem{jiraboard}
  JIRA board,
  \emph{https://www.atlassian.com/pl/software/jira}.   
  
\bibitem{reg}
  Regression testing,
  \emph{https://www.maveryx.com/automated-regression/?cn-reloaded=1}. 
\end{thebibliography}

\textbf{Additional materials} \begin{itemize}
	\item LaTeX wikibooks \newline \textit{https://en.wikibooks.org/wiki/LaTeX}

\end{itemize}
}
\newpage

\linespread{1.3}
\selectfont

\end{document}